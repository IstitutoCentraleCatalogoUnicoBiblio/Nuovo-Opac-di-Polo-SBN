package it.inera.opacsbn.solrmarc;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.codec.binary.Base64;
import org.marc4j.MarcStreamWriter;
import org.marc4j.marc.ControlField;
import org.marc4j.marc.DataField;
import org.marc4j.marc.Record;
import org.marc4j.marc.Subfield;
import org.marc4j.marc.VariableField;
import org.solrmarc.index.SolrIndexer;

import it.almaviva.sbnweb.util.CleanNoSort;
import it.inera.opacsbn.solrmarc.numeri.Numeri_tip;
import it.inera.opacsbn.solrmarc.rappres.Rappres_tip;


/**
 * 
 * @author Renato Eschini r.eschini@inera.it
 *
 */
public class OpacSbnIndexer extends SolrIndexer {

	/** Carattere di start del pretitolo **/
	public static String START_PRETITOLO = "\u0088";
	/** Carattere di end del pretitolo **/
	public static String END_PRETITOLO = "\u0089";

	public static String project = "sbn";

	/**
	 * File di properties con mapping:
	 */
	public static Properties props_bib = null;
	public static Properties props_prov = null;
	public static Properties props_raccolte = null;

	public final static String START_PRETITOLO_PROPS = "opac.start_pretitolo";
	public final static String END_PRETITOLO_PROPS = "opac.end_pretitolo";
	public final static String PROJECT_PROPS = "opac.project";

	/**
	 * File xml con i dati opacinfo da Opencms, per librarsi. Se nullo perch√® file inesistente, non viene valutato nei metodi che lo usano
	 */
	//public static InfoRecordsXml infoRecordsXml = null;

	public OpacSbnIndexer(String indexingPropsFile, String[] propertyDirs) {
		super(indexingPropsFile, propertyDirs);
		}

	/**
	 * 
	 * @param record
	 * @return
	 */
	public String getAbstract(final Record record) {
		// controllo se ho un file opacinfo.xml instanziato
		/*if (infoRecordsXml == null) return null;
		String bid = ((ControlField) record.getVariableField("001")).getData();
		try {
			return infoRecordsXml.getAbstract(bid);
		} catch (XPathExpressionException e) {
			e.printStackTrace();
		} */
		return null;
	}

	/**
	 * 
	 * @param record
	 * @return
	 */
	public String getIndice(final Record record) {
		// controllo se ho un file opacinfo.xml instanziato
	/*	if (infoRecordsXml == null) return null;
		String bid = ((ControlField) record.getVariableField("001")).getData();
		try {
			return infoRecordsXml.getIndice(bid);
		} catch (XPathExpressionException e) {
			e.printStackTrace();
		}*/
		return null;
	}

	/**
	 * 700:710 tutto separato da spazio tranne $3 e $4 
	 */
	public String getAutore(final Record record) {

		StringBuilder buffer = new StringBuilder("");

		List<VariableField> marcFieldList = record.getVariableFields("700");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					//String value = cleanPretitolo(subfield.getData());


					/* if (buffer.length() > 0 && !value.startsWith(",")) {
						buffer.append(" ");
					} */
					buffer.append(CleanNoSort.clean(subfield.getData()));

				}
			}

		}

		marcFieldList = record.getVariableFields("710");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					String value = cleanPretitolo(subfield.getData());
					/* if (buffer.length() > 0 && !value.startsWith(","))
						buffer.append(" "); */

					buffer.append(value);

				}
			}
		}

		if (buffer.length() > 0) {
			return buffer.toString();
		}
		return null;
	}

	/**
	 * 701:711 tutto separato da spazio tranne $3 e $4 
	 */
	public String getCoAutore(final Record record) {

		StringBuilder buffer = new StringBuilder("");

		List<VariableField> marcFieldList = record.getVariableFields("701");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					//String value = cleanPretitolo(subfield.getData());


					/* if (buffer.length() > 0 && !value.startsWith(",")) {
						buffer.append(" ");
					} */
					buffer.append(CleanNoSort.clean(subfield.getData()));

				}
			}

		}

		marcFieldList = record.getVariableFields("711");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					String value = cleanPretitolo(subfield.getData());
					/* if (buffer.length() > 0 && !value.startsWith(","))
						buffer.append(" "); */

					buffer.append(value);

				}
			}
		}

		if (buffer.length() > 0) {
			return buffer.toString();
		}
		return null;
	}


	/**
	 * 701:711 tutto separato da spazio tranne $3 e $4 
	 */
	public Set<String> getCoAutoreM(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		StringBuilder buffer = new StringBuilder("");

		List<VariableField> marcFieldList = record.getVariableFields("701");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					//String value = cleanPretitolo(subfield.getData());


					/* if (buffer.length() > 0 && !value.startsWith(",")) {
						buffer.append(" ");
					} */
					buffer.append(CleanNoSort.clean(subfield.getData()));

				}
			}
			if (buffer.length() > 0) {
				result.add (buffer.toString());
			        buffer = new StringBuilder("");
			}
		}

		marcFieldList = record.getVariableFields("711");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {

					String value = cleanPretitolo(subfield.getData());
					/* if (buffer.length() > 0 && !value.startsWith(","))
						buffer.append(" "); */

					buffer.append(value);

				}
			}
			if (buffer.length() > 0) {
				result.add (buffer.toString());
			        buffer = new StringBuilder("");
			}
   
		}

		return result;
	}

	/* 
		si prende tutto il 210 
		(primo)$a
		$a $a ecc
		 $b
		:$c
		,$d
		(primo)$e(
		;$e;$e ecc $f $f $f ecc :$g:$g ecc ,$h)
	 */
	public String getPublish(final Record record) {
		StringBuilder buffer = new StringBuilder("");

		boolean parentesi = false;
		boolean first = true;

		List<VariableField> marcFieldList = record.getVariableFields("210");
		for (VariableField vf : marcFieldList) {

			// $a $a $a $a ecc...
			DataField marcField = (DataField) vf;

			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();

				switch (code) {
				case 'a':
					if (buffer.length() > 0) buffer.append(" ; ");
					buffer.append(cleanPretitolo(subfield.getData()));
					break;
				case 'b':
					if (buffer.length() > 0) buffer.append(" ");
					buffer.append(subfield.getData());
					break;
				case 'c':
					buffer.append(" : ").append(subfield.getData());
					break;
				case 'd':
					buffer.append(", ").append(subfield.getData());
					break;
				case 'e':
					if (first) {
						buffer.append(" (").append(subfield.getData());
						first = false;
						parentesi = true;
					} else {
						buffer.append(" ; ").append(subfield.getData());
					}
					break;
				case 'f':
					buffer.append(" ").append(subfield.getData());
					break;
				case 'g':
					buffer.append(" : ").append(subfield.getData());
					break;
				case 'h':
					buffer.append(", ").append(subfield.getData());
					break;
				default:
					break;
				}

			}

		}
		if (parentesi) {
			buffer.append(")");
		}

		return buffer.toString();
	}

	public String getAllFieldsConcat(final Record record,String tagstr, String separator,String nosub) {
		StringBuilder buffer = new StringBuilder("");

		if (separator == null)
			separator = " - ";
		List<VariableField> marcFieldList = record.getVariableFields(tagstr);
		for (VariableField vf : marcFieldList) {

			// $a $a $a $a ecc...
			DataField marcField = (DataField) vf;

			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();
				if (nosub != null && nosub.contains(code+""))
					continue;
				if (buffer.length() > 0) buffer.append(separator);
				buffer.append(subfield.getData());

			}

		}

		return buffer.toString();
	}
	
	public Set<String> getCollocazione(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		
		StringBuilder buffer = new StringBuilder("");
		List<VariableField> marcFieldList = record.getVariableFields("950");
		for (VariableField vf : marcFieldList) {

			DataField marcField = (DataField) vf;
			boolean firstE = true;
			
			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();
				
				if (code == 'd') {
					firstE = true;
					if (buffer.length() > 0) {
						result.add (buffer.toString());
						buffer = new StringBuilder("");
					}
					buffer.append(subfield.getData().substring(3));
	
				}
				if (code == 'e') {
					if (firstE) {
						if (subfield.getData().length() > 24) {
						String seq = subfield.getData().substring(24);
						if (seq.length() > 20)
							   seq = seq.substring(0,20);
						if (seq != null)
							seq = seq.trim();
						if (!(seq.isEmpty()))
						  buffer.append(" ").append(seq);
						}
						firstE = false;
					}
				}
			}
		}
		if (buffer.length() > 0)
			result.add (buffer.toString());
		return result;
		
		
	}

	public String getSubString(final Record record,String tagstr, String from) {
		StringBuilder buffer = new StringBuilder("");
		int fromI = 0;
		try {
			 fromI = Integer.parseInt(from);
		} catch (NumberFormatException nfe) { 
		   fromI = 0;
		}
		
		Set<String> field = getFieldList(record, tagstr);
		for (Iterator<String> iterator = field.iterator(); iterator.hasNext();) {
		   
			//String data= iterator.next();
			// logger.error("getSubString: data " +  data);
			buffer.append(iterator.next().substring(fromI));
			
		}	

		return buffer.toString();
	}

	/*
	 isbd = 200
		(primo)$a
		;$a;$a ecc
		(primo)[$b $b $b ecc] 
		.$c.$c ecc
		=$d=$d ecc
		:$e:$e ecc
		/$f/$f ecc
		;$g;$g ecc
		;$v;$v ecc
	 */
	public String getIsbd(final Record record) {
		StringBuilder buffer = new StringBuilder("");

		List<VariableField> marcFieldList = record.getVariableFields("200");
		for (VariableField vf : marcFieldList) {

			// (primo)$a;$a;$a ecc
			DataField marcField = (DataField) vf;


			boolean firstA = true;

			boolean parentesiB = false;
			int idxLastB = 0;
			boolean firstB = true;

			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();


				switch (code) {

				case 'a':
					if (firstA) {
						buffer.append(cleanPretitolo(subfield.getData()));
						firstA = false;
					} else {
						buffer.append(" ; ").append(cleanPretitolo(subfield.getData()));	
					}
					break;

				case 'b':
					if (firstB) {
						buffer.append(" [").append(subfield.getData());
						firstB = false;
						parentesiB = true;
						idxLastB = buffer.length();
					} else {
						buffer.append(" ").append(subfield.getData());
						idxLastB = buffer.length();
					}
					break;

				case 'c':
					buffer.append(" . ").append(subfield.getData());
					break;

				case 'd':
					buffer.append(" = ").append(subfield.getData());
					break;

				case 'e':
					buffer.append(" : ").append(subfield.getData());
					break;

				case 'f':
					buffer.append(" / ").append(subfield.getData());
					break;

				case 'g':
					buffer.append(" ; ").append(subfield.getData());
					break;

				case 'v':
					buffer.append(" ; ").append(subfield.getData());
					break;

				default:
					break;
				}	
			}

			// inserisco la parentesi dopo l'ultima b inserita
			if (parentesiB) {
				buffer.insert(idxLastB, "] ");
			}

		}

		return buffer.toString();
	}


	/*
	 isbd = 200
		(primo)$a
		;$a;$a ecc
		(primo)[$b $b $b ecc] 
		.$c.$c ecc
		=$d=$d ecc
		:$e:$e ecc
		/$f/$f ecc
		;$g;$g ecc
		;$v;$v ecc
	 */
	public String getIsbdSimili(final Record record) {
		StringBuilder buffer = new StringBuilder("");

		List<VariableField> marcFieldList = record.getVariableFields("200");
		for (VariableField vf : marcFieldList) {

			// (primo)$a;$a;$a ecc
			DataField marcField = (DataField) vf;


			boolean firstA = true;

			boolean parentesiB = false;
			int idxLastB = 0;
			boolean firstB = true;

			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();


				switch (code) {

				case 'a':
					if (firstA) {
						buffer.append(cleanPretitolo(subfield.getData()));
						firstA = false;
					} else {
						buffer.append(" ; ").append(cleanPretitolo(subfield.getData()));	
					}
					break;

				case 'b':
					if (firstB) {
						buffer.append(" [").append(subfield.getData());
						firstB = false;
						parentesiB = true;
						idxLastB = buffer.length();
					} else {
						buffer.append(" ").append(subfield.getData());
						idxLastB = buffer.length();
					}
					break;

				case 'c':
					buffer.append(" . ").append(subfield.getData());
					break;

				case 'd':
					buffer.append(" = ").append(subfield.getData());
					break;

				default:
					break;
				}	
			}

			// inserisco la parentesi dopo l'ultima b inserita
			if (parentesiB) {
				buffer.insert(idxLastB, "] ");
			}

		}

		return buffer.toString();
	}


	/**
	 * prima   parte: 700-750 a,b,c,d,e,f,g (separati da spazio)  
	 * 
	 * 
	 * seconda parte: 790-791 b <c> : d  : g f  ‚Üí z 
	 * 
	 * 
	 * terza   parte: 927 c  
	 * 
	 * 
	 * quarta  parte: 411-499  prefix 1700, 1710  a,b,c,d,e,f,g (separati da spazio)  
	 * 
	 * 
	 * quinta  parte: 500 $9
	 * 
	 * 
	 * 
	 * tipo archivio = header pos. 19      se vale I o A === 790-791 b <c> :d  :g f ALTRIMENTI 790-791 b c :d  :g f
	 * 
	 * @param record
	 * @return
	 */
	public Set<String> getNome(final Record record) {
		Set<String> result = getNomeGenerico(record, null, false, false);       
		return result;
	}

	/**
	 * come getNome ma filtrata per $4
	 */
	public Set<String> getNomeRel(final Record record, String $4) {
		Set<String> result = getNomeGenerico(record, $4, false, false);
		return result;
	}

	/**
	 * come getNome ma senza 790-791
	 */
	public Set<String> getNomef(final Record record) {
		Set<String> result = getNomeGenerico(record, null, true, false);
		return result;
	}


	/**
	 * come getNomeVid
	 */
	public Set<String> getNomeVid(final Record record) {
		Set<String> result = getNomeGenerico(record, null, false, true);  
		return result;
	}


	/**
	 * Se $4 == null return true;
	 * Se $4 != null && marcField.getSubfields('4') == $4 return true
	 * else return false;
	 */
	public boolean isNome(DataField marcField, String $4) {
		boolean test = true;
		if ($4 != null) {
			test = false;
			List<Subfield> checkSubfields = marcField.getSubfields('4');
			for (Subfield checkSubfield : checkSubfields) {
				if ($4.equalsIgnoreCase(checkSubfield.getData())) test = true; 
			}
		}
		return test;
	}
//  getNomef   getNomeGenerico(record, null, true, false);
// getNome --> getNomeGenerico(record, null, false, false);  
	public Set<String> getNomeGenerico(final Record record, String $4, boolean nomef, boolean nomeVid) {
		Set<String> result = new LinkedHashSet<String>();
		String separator = "";
		if ("sbnweb".equals(project))
			separator = " ";

		/**
		 *  prima parte: 700-750 a,b,c,d,e,f,g (separati da spazio)
		 */
		int startTag = 700;
		int endTag = 750;


		String subfldTags = "[a|b|c|d|e|f|g]"; 
		if (nomeVid) { // $3<---- vid
			subfldTags = "[3]";
		}

		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
			if (!marcFieldList.isEmpty()) {
				Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
				for (VariableField vf : marcFieldList) {
					DataField marcField = (DataField) vf;

					if (isNome(marcField, $4)) {
						StringBuilder buffer = new StringBuilder("");
						List<Subfield> subfields = marcField.getSubfields();
						for (Subfield subfield : subfields) {
							Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
							if (matcher.matches()) {
								if (buffer.length() > 0 && !subfield.getData().startsWith(","))
									buffer.append(separator != null ? separator : "");
								buffer.append(subfield.getData());
							}
						}
						if (buffer.length() > 0) {
							if (tag > 709 && tag < 720)
								result.add(cleanPretitolo(buffer.toString()));
							else
								result.add(buffer.toString());
						}
					}

				}

			}
		}

		// se √® nomef non passo da qui...
		if (!nomef) {
			/**
			 *  seconda parte: 790-791 b <c> : d  : g f  ‚Üí z
			 */
			startTag = 790;
			endTag = 791;
			subfldTags = "[a|b|c|d|e|g|f|z|y]";

			if (nomeVid) {  // $3<---- vid
			    subfldTags = "[a|b|c|d|e|g|f|3|y]";
			}

			// itero sui tag
			for (int tag = startTag; tag <= endTag; tag++) {
				List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
				if (!marcFieldList.isEmpty()) {
					Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
					for (VariableField vf : marcFieldList) {
						DataField marcField = (DataField) vf;

						if (isNome(marcField, $4)) {
							StringBuilder buffer = new StringBuilder("");
							String vid = "";
							List<Subfield> subfields = marcField.getSubfields();
							for (Subfield subfield : subfields) {
								Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
								if (matcher.matches()) {

									if (buffer.length() > 0 && !subfield.getData().startsWith(","))
										buffer.append(separator != null ? separator : " ");

									String data = subfield.getData();

									/*// se il subfield √® c controllo < >
									if ('c' == subfield.getCode()) {
										if (!data.trim().startsWith("<")) data = "<".concat(data);
										if (!data.trim().endsWith(">")) data = data.concat(">");
									}

									// se il subfield √® d o g metto i due punti
									if ('d' == subfield.getCode() || 'g' == subfield.getCode()) {
										data = " : ".concat(data);
									}*/
									// se il subfield √® z metto ‚Üí
									if ('z' == subfield.getCode()) {
										data = " -> ".concat(data);
									}
									if ('3' == subfield.getCode()) {
									   vid = data;
									}
									else if ('y' == subfield.getCode() && !buffer.toString().trim().equals(data.trim())) {
										buffer.delete(0,buffer.length());

										if (!nomeVid) {
										 buffer.append(data);
										}
										else
										  vid = "";
									}
									else
									// b e f entrano come arrivano...
									buffer.append(data);
								}
							}
							if (nomeVid && !vid.isEmpty()) {
								result.add(vid);

							}
							else if (buffer.length() > 0) {
								if (tag == 791)
									result.add(cleanPretitolo(buffer.toString()));
								else
									result.add(buffer.toString());

							}
						}
					}
				}
			}
		}
		if (!"sbnweb".equals(project)) {
			/**
			 * terza parte 927c  // $3<----
			 */
			char subField = 'c';

			if (nomeVid) {  // $3<---- vid
				subField = '3';
			}
			if ($4 == null) { // solo se $4 == null, sono in nome e non in nome_rel_$4
				List<VariableField> marcField927List = record.getVariableFields("927");
				for (VariableField vf : marcField927List) {
					DataField marcField927 = (DataField) vf;
					List<Subfield> subfield927cList = marcField927.getSubfields(subField);
					for (Subfield subfield : subfield927cList) {
						if (subfield.getData() != null && !"".equals(subfield.getData())) {
							result.add(subfield.getData());
						}
					}
				}
			}
			/**
			 * quarta  parte: 411-499  prefix 1 700, 1 710  a,b,c,d,e,f,g (separati da spazio)  
			 */
			if ($4 == null) { // solo se $4 == null, sono in nome e non in nome_rel_$4

				startTag = 410;
				endTag = 499;
				subfldTags = "[a|b|c|d|e|f|g]";
				if (nomeVid) {  // $3<---- vid
					subfldTags = "[3]";
				}

				// itero sui tag
				for (int tag = startTag; tag <= endTag; tag++) {
					List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
					if (!marcFieldList.isEmpty()) {
						Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
						for (VariableField vf : marcFieldList) {
							DataField marcField = (DataField) vf;
							boolean good = false;
							StringBuilder buffer = new StringBuilder("");
							List<Subfield> subfields = marcField.getSubfields();
							for (Subfield subfield : subfields) {
								String subfieldString = subfield.toString();
								if (good && buffer.length() > 0 && subfieldString.startsWith("$17") ){
									result.add(buffer.toString());
									buffer = new StringBuilder("");
									// buffer.delete(0, buffer.length());
								}
								if (subfieldString.startsWith("$17") ) good = true;
								if (subfieldString.startsWith("$1200")) good = false;
								if (tag == 463 && (subfieldString.startsWith("$1702") || subfieldString.startsWith("$1712"))) good = false;
								if (good) {
									/* if (new_field && buffer.length() > 0) {
									    result.add(buffer.toString());
									    // buffer.delete(0, buffer.length());
									    buffer = new StringBuilder("");
								} */
									Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
									if (matcher.matches()) {
										if (buffer.length() > 0 && !subfield.getData().startsWith(",")) buffer.append(separator != null ? separator : "");
										if (subfieldString.startsWith("$171"))
											buffer.append(cleanPretitolo(subfield.getData()));
										else
											buffer.append(subfield.getData());	
									}
								}
							}
							if (buffer.length() > 0) result.add(buffer.toString()); 
						}
					}
				}



			}

			/**
			 * quinta  parte: 500 $9  
			 */
			subField = '9';

			if (nomeVid) {  //  vid per il momento non presente : quindi inserito else e subField = '0'
				subField = '0';
			}

			else if ($4 == null) { // solo se $4 == null, sono in nome e non in nome_rel_$4
				List<VariableField> marcField500List = record.getVariableFields("500");
				for (VariableField vf : marcField500List) {
					DataField marcField500 = (DataField) vf;
					List<Subfield> subfield500cList = marcField500.getSubfields(subField);
					for (Subfield subfield : subfield500cList) {
						if (subfield.getData() != null && !"".equals(subfield.getData())) {
							result.add(subfield.getData());
						}
					}
				}
			}
		}
		result = getFold(result); 

		return result;
	}

	/**
	 * 600-675 a,  - x ,b, c, d
	 * @param record
	 * @return
	 */
	public Set<String> getSoggettoCBL(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		String separator = " ";

		/**
		 *  600-675 a,  - x ,b, c, d (separati da spazio) e non 620
		 */
		int startTag = 600;
		int endTag = 617;
		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			if (tag == 609 || (tag >= 611 && tag <= 614))
				continue;
			List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
			if (!marcFieldList.isEmpty()) {
				for (VariableField vf : marcFieldList) {
					DataField marcField = (DataField) vf;
					StringBuilder buffer = new StringBuilder("");
					List<Subfield> subfields = marcField.getSubfields();
					for (Subfield subfield : subfields) {
						if ('3' != subfield.getCode() && subfield.getCode() != '2') {

							if (buffer.length() > 0)
								buffer.append(separator != null ? separator : " ");

							String data = subfield.getData();

							// se il subfield √® x metto - 
							if ('x' == subfield.getCode()) {
								data = "- ".concat(data);
							}


							// a b c d entrano come arrivano...
							buffer.append(data);
						}
					}
					if (buffer.length() > 0)
						result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
				}

			}
		}

		return result;
	}


	/**
	 * 600-675 a,  - x ,b, c, d
	 * @param record
	 * @return
	 */
	public Set<String> getSoggetto(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		String separator = " ";

		/**
		 *  600-675 a,  - x ,b, c, d (separati da spazio) e non 620
		 */
		int startTag = 600;
		int endTag = 675;
		String subfldTags = "[a|x|b|c|d|2]"; /* "[a|x|b|c|d|2] non  necessario ticket */

		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			if (tag == 620)
				continue;
			List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
			if (!marcFieldList.isEmpty()) {
				Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
				for (VariableField vf : marcFieldList) {
					DataField marcField = (DataField) vf;
					StringBuilder buffer = new StringBuilder("");
					List<Subfield> subfields = marcField.getSubfields();
					for (Subfield subfield : subfields) {
						Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
						if (matcher.matches()) {

							if (buffer.length() > 0)
								buffer.append(separator != null ? separator : " ");

							String data = subfield.getData();

							// se il subfield √® x metto - 
							if ('x' == subfield.getCode()) {
								data = "- ".concat(data);
							}

							if ('2' == subfield.getCode()) {
								data = ". ".concat(data);
							}

							// a b c d entrano come arrivano...
							buffer.append(data);
						}
					}
					if (buffer.length() > 0)
						result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
				}

			}
		}

		return result;
	}


	/**
	 * 600-675 a,  - x ,b, c, d
	 * @param record
	 * @return
	 */
	public Set<String> getSoggettoF(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		String separator = " ";

		/**
		 *  600-675 a,  - x ,b, c, d (separati da spazio) e non 620
		 */
		int startTag = 600;
		int endTag = 675;
		String subfldTags = "[a|x|b|c|d]"; /* "[a|x|b|c|d] non  necessario ticket */

		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			if (tag == 620)
				continue;
			List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
			if (!marcFieldList.isEmpty()) {
				Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
				for (VariableField vf : marcFieldList) {
					DataField marcField = (DataField) vf;
					StringBuilder buffer = new StringBuilder("");
					List<Subfield> subfields = marcField.getSubfields();
					for (Subfield subfield : subfields) {
						Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
						if (matcher.matches()) {

							if (buffer.length() > 0)
								buffer.append(separator != null ? separator : " ");

							String data = subfield.getData();

							// se il subfield √® x metto - 
							if ('x' == subfield.getCode()) {
								data = "- ".concat(data);
							}

							// a b c d entrano come arrivano...
							buffer.append(data);
						}
					}
					if (buffer.length() > 0)
						result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
				}

			}
		}

		return result;
	}

	/**
	 * 200 $a,$e
	 * 454 $a,$e (454 √® essenziale)
	 * 461 $a,$e
	 * 462 $a,$e (per sicurezza; anche se non so immaginare la situazione)
	 * @param record
	 * @return
	 */
	public Set<String> getTitoloNav(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		String separator = " ";

		String subfldTags = "[a|e]"; 

		List<VariableField> marcFieldList = record.getVariableFields("200");
		if (!marcFieldList.isEmpty()) {
			Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
			for (VariableField vf : marcFieldList) {
				DataField marcField = (DataField) vf;
				StringBuilder buffer = new StringBuilder("");
				List<Subfield> subfields = marcField.getSubfields();
				boolean initial_a = true;
				for (Subfield subfield : subfields) {
					Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());

					if (matcher.matches()) {

						if (buffer.length() > 0)
							buffer.append(separator != null ? separator : " ");

						String data = subfield.getData();

						// se il subfield √® e metto : 
						if ('e' == subfield.getCode()) {
							data = ":".concat(data);
						}
						// successive a metto ;
						else if (!initial_a){
							data = ";". concat(data);
						}
						else {
							data = cleanPretitolo(data);
							initial_a = false;
						}

						buffer.append(data);
					}
				}
				if (buffer.length() > 0) {
					String cleanedBuff = buffer.toString().replaceAll("\\s*\\.?\\s*-?\\s*$", "");
					result.add(String.valueOf(foldToASCII(cleanedBuff.toCharArray(), cleanedBuff.length())).trim());
				}
			}

		}	   
		result.addAll(getTitNav_$(record,"454"));
		result.addAll(getTitNav_$(record,"461"));
		result.addAll(getTitNav_$(record,"462"));
		return result;
	}


	/**
	 * 
	 * @param record
	 * @param lowerBoundStr
	 * @param upperBoundStr
	 * @param subField
	 * @return
	 */
	public Set<String> getAllSearchableFields(final Record record, String lowerBoundStr, String upperBoundStr, String subField, String fold) {

		Set<String> result = new LinkedHashSet<String>();

		int lowerBound = localParseInt(lowerBoundStr, 100);
		int upperBound = localParseInt(upperBoundStr, 900);

		List<DataField> fields = record.getDataFields();
		for (DataField field : fields) {
			int tag = localParseInt(field.getTag(), -1);
			if ((tag >= lowerBound) && (tag < upperBound)) {
				Pattern subfieldPattern = Pattern.compile(subField.length() == 0 ? "." : subField);
				List<Subfield> subfields = field.getSubfields();
				for (Subfield subfield : subfields) {
					Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
					if (matcher.matches()) {
						String data = subfield.getData();
						result.add(data);
					}
				}    			
			}
		}

		result = cleanPretitolo(result,fold); // clean del pretitolo

		return result;
	}

	public Set<String> getNumeriTipY(final Record record) {
		return Numeri_tip.getResult(record, "071", "30", null, null, "a");
	}
	/**
	 * solo per i numeri con TIP E,L,O,X,Y,V,W e A,F
	 */
	public Set<String> getNumeri_tip_$(final Record record, String tip) {
		if ("A".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "0", null, null, "az");
		}
		if ("F".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "1", null, null, "az");
		}
		if ("H".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "4", null, null, "az");
		}
		// da capire che numero √® E ? quale indicatore 3 o 4 ?
		if ("E".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "3", null, null, "az");
		}
		if ("L".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "2", null, null, "az");
		}
		if ("O1".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "071", "6", null, null, "az");
		}
		if ("O".equalsIgnoreCase(tip)) {
			Set<String> result = getFieldList(record, "929b");
			result.addAll(getOperaNum(result));
			result.addAll(Numeri_tip.getResult(record, "017", "01", null, null, "a"));
			return result;
		}
		if ("X".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "017", "70", "2", "X", "a");
		}
		if ("Y".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "017", "70", "2", "Y", "a");
		}
		if ("U".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "017", "70", "2", "U", "a");
		}
		if ("P1".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "017", "70", "2", "P", "a");
		}
		// SIAE non Segnatura
		if ("W1".equalsIgnoreCase(tip)) {
			return Numeri_tip.getResult(record, "017", "70", "2", "W", "a");
		}

		//V:   929 c    17 ind 70 a $2 = V
		if ("V".equalsIgnoreCase(tip)) {
			Set<String> result = new LinkedHashSet<String>();

			Set<String> tag929c = getFieldList(record, "929c");
			result.addAll(tag929c);

			List<VariableField> field = (List<VariableField>) record.getVariableFields("017");
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				char ind1 = dataField.getIndicator1();
				char ind2 = dataField.getIndicator2();
				if (ind1 == '7' || ind2 == '0') {

					// cerco il $2
					boolean found = false;
					List<Subfield> subflds = dataField.getSubfields('2');
					for (Iterator<Subfield> iteratorSubflds = subflds.iterator(); iteratorSubflds.hasNext();) {
						Subfield subfield = (Subfield) iteratorSubflds.next();
						if (tip.equalsIgnoreCase(subfield.getData())) {
							found = true;
							break;
						}
					}
					// prendo il $a e lo aggiungo ai risultati
					if (found) {
						subflds = dataField.getSubfields('a');
						for (Iterator<Subfield> iteratorSubflds = subflds.iterator(); iteratorSubflds.hasNext();) {
							Subfield subfield = (Subfield) iteratorSubflds.next();
							result.add(subfield.getData());
						}
					}
				}
			}
			return result;
		}

		//W:            Caricare il valore per la ricerca dal tag 899 subfield $1 , $3 e $c separati da spazio. 
		if ("W".equalsIgnoreCase(tip)) {
			Set<String> result = new LinkedHashSet<String>();

			List<VariableField> field = (List<VariableField>) record.getVariableFields("899");
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				Subfield subfld$1 = dataField.getSubfield('1');
				Subfield subfld$3 = dataField.getSubfield('3');
				Subfield subfld$c = dataField.getSubfield('c');
				StringBuilder buffer = new StringBuilder();
				if (((subfld$3 == null || subfld$3.getData() == null ||  "".equalsIgnoreCase(subfld$3.getData().trim()))) &&
						(subfld$c == null || subfld$c.getData() == null ||  "".equalsIgnoreCase(subfld$c.getData().trim()))	) 
					continue;

				if (subfld$1 != null && subfld$1.getData() != null &&  !"".equalsIgnoreCase(subfld$1.getData().trim())) {
					buffer.append(subfld$1.getData());
					buffer.append(" ");
				}
				if (subfld$3 != null && subfld$3.getData() != null &&  !"".equalsIgnoreCase(subfld$3.getData().trim())) {
					buffer.append(subfld$3.getData());
					buffer.append(" ");
				}
				if (subfld$c != null && subfld$c.getData() != null &&  !"".equalsIgnoreCase(subfld$c.getData().trim())) {
					buffer.append(subfld$c.getData());
				}
				if (buffer.length() > 0) {
					result.add(buffer.toString().trim());	
				}
			}
			return result;
		}
		return null;
	}

	public Set<String> getFieldRange(final Record record, String tagStr, String from, String to, String length) {
		Set<String> result = new LinkedHashSet<String>();

		int start = localParseInt(from, 1);
		int end = localParseInt(to, 1);
		int numchars = localParseInt(length, 1);
		for (int i=start; i<=end ;i=i+numchars) {
			int fin = i+numchars;
			result.addAll(getFieldList(record, tagStr +"[" + i + "-" + fin + "]"));
		}
		return result;
	}
	public Set<String> getPresentazione(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		List<VariableField> marcFieldList = record.getVariableFields("125");
		for (VariableField vf : marcFieldList) {

			DataField marcField = (DataField) vf;
			List<Subfield> subfields =  marcField.getSubfields();
			boolean addC = false;
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();
				if (code == 'a'  && (!"m".equalsIgnoreCase(subfield.getData().toCharArray()[0] + "")))
					result.add(subfield.getData());
				else if (code == 'a')
					addC = true;
				else if (code == 'c' && addC) {
					result.addAll(getFieldRange(record, "125", "0", subfield.getData().length() + "", "1"));
				}

			}
		}

		return result;
	}


	/**
	 * organico_tip_3 e organico_tip_4
	 */
	public Set<String> getOrganico_tip(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();
		Set<String> field = getFieldList(record, tagStr);
		for (Iterator<String> iterator = field.iterator(); iterator != null  && iterator.hasNext();) {
			String data = iterator.next();
			if (data.contains("(")) {
				String[] elements = data.split("\\(");
				Boolean first = true;
				String before = "";

				for (int i=0; i<elements.length; i++) {
					String[] subels = elements[i].split("\\)",2);
					if (subels.length > 1)
						elements [i] = subels[1].replaceAll("\\$", "");
					if ( elements[i].replaceAll(" ", "").length() > 0) {
						if (elements[i].startsWith(","))
							elements[i] = elements[i].substring(1).replaceAll(" ", "");

					}	
					String[] words = elements[i].split("[,/%]%*");
					if (first) {
						first = false;
						before = subels[0].replaceAll(" ", "");
					}
					else {
						result.add(before.concat("(").concat(subels[0].concat(")")));
					}
					if (words != null && words.length > 0) {
						before = words[words.length -1];
						if (before != null && before.length() > 0)
							before = before.replaceAll(" ", "");	
						for	 (int k=0; k< words.length -1; k++) {
							String tmp_wd = words[k]; 
							if (tmp_wd != null && tmp_wd.length() > 0)
								result.add(tmp_wd .replaceAll(" ", ""));
						}
					}
				}
				if (before.length()>0)
					result.add(before);
			}
			else {
				String[] elements = data.replaceAll("\\$", "").split("[,/%]%*");
				for (int i=0; i<elements.length; i++) {
					if (elements[i] != null && elements[i].replaceAll(" ", "").length() > 0)
						result.add(elements[i].replaceAll(" ", ""));
				}
			}
		}
		return result;
	}

	/**
	 * 
	 */
	public Set<String> getRappres_tip(final Record record, String n) {
		if ("2".equalsIgnoreCase(n)) {
			// 922 p,q,r,s,t,u con $a = 2
			return Rappres_tip.getResult(record, "922", "[p|q|r|s|t|u]", "a", "2");
		}
		if ("4".equalsIgnoreCase(n)) {
			// 922 p,q,r,s,t,u con $a = 4
			return Rappres_tip.getResult(record, "922",  "[p|q|r|s|t|u]", "a", "4");
		}
		if ("5".equalsIgnoreCase(n)) {
			// 922 p,q,r,s,t,u con $a = 5
			return Rappres_tip.getResult(record, "922",  "[p|q|r|s|t|u]", "a", "5");
		}
		return null;
	}


	/**
	 * 921 b c (separati da ‚Äì e racchisi da parentesi)
	 * @param record
	 * @return
	 */
	public  Set<String> getMarca(final Record record) {

		/* 
		 * 921 $a identificativo della marca (da mascherare)
		 * 921 $b descrizione della marca
		 * 921 $e motto (preceduto da "punto spazio)
		 * 921 $d collocazione della marca nella pubblicazione (es. "sul front."), preceduto da "virgola spazio"
		 * 921 $c (ripetibile) citazione (codici eventualmente separati da "virgola spazio", e racchiusi tra parentesi tonde) 
		 */

		Set<String> result = new LinkedHashSet<String>();

		List<VariableField> marcFieldList = record.getVariableFields("921");
		for (VariableField vf : marcFieldList) {

			DataField marcField = (DataField) vf;
			StringBuilder buffer = new StringBuilder("");

			boolean parentesiC = false;
			boolean firstC = true;
			int idxLastC = 0;

			List<Subfield> subfields =  marcField.getSubfields();
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();


				switch (code) {
				case 'b':
					buffer.append(subfield.getData());
					break;
				case 'e':
					buffer.append(". ").append(subfield.getData());
					break;
				case 'c':
					if (firstC) {
						buffer.append(" (").append(subfield.getData());
						firstC = false;
						parentesiC = true;
						idxLastC = buffer.length();
					} else {
						buffer.append(", ").append(subfield.getData());
						idxLastC = buffer.length();
					}
					break;


				default:
					break;
				}	
			}

			// inserisco la parentesi dopo l'ultima b inserita
			if (parentesiC) {
				buffer.insert(idxLastC, ")");
			}
			result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
		}

		return result;
	}

	/*
	guida posizione 6 (partendo da 0) 
		se vale e oppure f va messo a C
		se vale i oppure j oppure k va messo a S
		altrimenti si legge l'id del record e 
			se a pos. 11 c'e' E allora si mette A
			se contiene MUS oppure MSM si mette M
		in tutti gli altri casi si mette I

	 */
	public String getBaseProv(final Record record) {
		String result = new String();
		String leader = record.getLeader().toString();
		char baseProv = leader.charAt(6);

		String id = ((ControlField) record.getVariableField("001")).getData();
		if (baseProv == 'e' || baseProv == 'f') {
			result = "C";
		} else if (baseProv == 'i' || baseProv == 'j' || baseProv == 'k') {
			result = "S";
		} else if (id != null && id.length() > 11 && id.charAt(11) == 'E') {
			result = "A";
		} else if (id != null && id.indexOf("MUS") != -1 || id.indexOf("MSM") != -1) {
			result = "M";
		} else {
			result = "I";
		}

		return result;
	}

	public String getLevel(final Record record) {
		String result = new String();
		String leader = record.getLeader().toString();
		char level = leader.charAt(7);
		if (level == 's') {
			Set<String> field = getFieldList(record, "110a");
			
			if (field != null && field.size() > 0  && ((String)field.toArray()[0]).substring(0,1).equalsIgnoreCase("b")) 
				level = 'c';
		} 
		result = level + "";
		return result;
	}

	public Set<String> getTipoMatIccu(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		String leader = record.getLeader().toString();
		char baseProv = leader.charAt(6);
		String id = ((ControlField) record.getVariableField("001")).getData();
		Set<String> vals92x = getFieldList(record, "928a:928b:928c:928d:929a:929e:929c");

		boolean preslibr = false;
		Set<String> vals140 = getFieldList(record, "140a");
		if (vals140 != null) {
		for (Iterator<String> iterator = vals140.iterator(); iterator.hasNext();) {
			String data= (String)iterator.next();
			// logger.warn("Ciao a:x" + data.substring(17,19));
			if ((data != null)  && (data.substring(17,19)).equals("da")) {
				preslibr = true;
				break;
			}
		}
		}
		if (!preslibr) {
			Set<String> vals105 = getFieldList(record, "105a");
			if (vals105 != null) {
			for (Iterator<String> iterator = vals105.iterator(); iterator.hasNext();) {
				String data= (String)iterator.next();
				// logger.warn("Ciao m:" + data.substring(11));
				if (data != null && data.substring(11,12).equals("i")) {
					preslibr = true;
					break;
				}
			}
		  }
		}
		//logger.warn("Ciao pres :" + preslibr);

		 if (baseProv == 'c' || baseProv == 'd' || ((baseProv == 'b' || baseProv == 'a') && preslibr) || baseProv == 'j' || id.indexOf("MUS") != -1 ||
			id.indexOf("MSM") != -1  || (baseProv == 'g' && vals92x.size() > 0) )
	        result.add("M");
	    if (id.length() > 12 && id.charAt(11) == 'E')
		result.add("A");
	    else if (id.indexOf("MUS") == -1 && id.indexOf("MSM") == -1)
		result.add("N");

		return result;
	}


	public Set<String> getTipoMat(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		String leader = record.getLeader().toString();
		char baseProv = leader.charAt(6);
		String id = ((ControlField) record.getVariableField("001")).getData();
		Set<String> vals92x = getFieldList(record, "928a:928b:928c:928d:929a:929e:929c");
		Set<String> vals125 = getFieldList(record, "125b");
		boolean pres125 = false;
		for (Iterator<String> iterator = vals125.iterator(); iterator.hasNext();) {
			String data= (String)iterator.next();
			if (data.contains("b")) {
				pres125 = true;
				break;
			}
		}

		if (baseProv == 'c' || baseProv == 'd' || ((baseProv == 'b' || baseProv == 'a') && pres125) || baseProv == 'j' || id.indexOf("MUS") != -1 || 
				id.indexOf("MSM") != -1  || (baseProv == 'g' && vals92x.size() > 0) ) 
			result.add("M");
		if (id.length() > 12 && id.charAt(11) == 'E')
			result.add("A");
		else if (id.indexOf("MUS") == -1 && id.indexOf("MSM") == -1)
			result.add("N");

		return result;
	}

	public String getFormatoElettronico(final Record record, String tagStr) {
		Set<String> result = getFieldList(record, tagStr);
		String val = "Y";
		if (result.size() > 0)
			return val;
		else {
			Set<String> result2 = getFieldList(record, "899e");
			if (result2.contains("S"))
				return val;
		}
		return "";
	}

	public String getPresenza(final Record record, String tagStr) {
		Set<String> result = getFieldList(record, tagStr);
		String val = "Y";
		if (result.size() > 0)
			return val;
		return "";
	}

	public String getAntico(final Record record, String tagStr) {
		Set<String> result = getFieldList(record, tagStr);
		String val = "Y";
		if (result.size() > 0)
			return val;
		String bid = ((ControlField) record.getVariableField("001")).getData();
		if (bid.substring(3,4).equalsIgnoreCase("E"))
			return val;
		result = getFieldList(record, "100a[9-12]:100a[13:16]");
		Iterator<String> iterator = result.iterator(); 
		String datada = "";
		String dataa = "";
		if (iterator.hasNext()) 
			datada = ((String) iterator.next()).replaceAll(" ", "");
		if (iterator.hasNext()) 
			dataa = ((String) iterator.next()).replaceAll(" ", "");
		if (dataa.length() > 0 && validDate(dataa) && Integer.parseInt(dataa) < 1830)
			return val;
		if (datada.length() > 0 && validDate(datada) && Integer.parseInt(datada) < 1830)
			return val;
		return "";
	}

	public Set<String> getGraficaDisegno(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();
		Set<String> field4 = getFieldList(record, tagStr + "[4-5]");
		Set<String> field10 = getFieldList(record, tagStr + "[10-11]");
		Iterator<String> iterator2 = field10.iterator();
		for (Iterator<String> iterator = field4.iterator() ; iterator.hasNext();) {
			String data = (String)iterator.next();
			String data2 = "";
			if (iterator2.hasNext())
				data2 = (String)iterator2.next();
			if ("xx".equalsIgnoreCase(data.trim()) && !"xx".equalsIgnoreCase(data2.trim()))
				result.add("D");
			if ("xx".equalsIgnoreCase(data2.trim()) && !"xx".equalsIgnoreCase(data.trim()))
				result.add("S");
		}
		return result;

	}
	public String getCartTradFoto(final Record record) {

		Set<String> field121 = getFieldList(record, "121a");
		Set<String> field120 = getFieldList(record, "120a");
		if (field121.size() > 0)
			return "F";
		else if (field120.size() > 0)
			return "C";
		return "";

	}
	public Set<String> getFormatoDist(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		Set<String> field115 = getFieldList(record, "115a");
		for (Iterator<String> iterator = field115.iterator() ; iterator.hasNext();) {
		   String value = (String)iterator.next();
		   result.add(value.substring(0,1) + value.substring(6,7) + value.substring(8,9) + value.substring(15,17));
		}
		return result;

	}

	public Set<String> getTipoScala(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();
		List<VariableField> fieldList =  record.getVariableFields(tagStr);
		for (VariableField vf : fieldList) {
			DataField data = (DataField) vf;
			result.add(data.getIndicator1() + "");
		}
		return result;



	}
	/**
	 * 
	 * 210c , 700-750 a,b,c,d,f,g (separati da spazio) con $4 650 o 750
	 * @deprecated Configurato solo il 210c nel file di configurazione
	 */
	public Set<String> getEditore(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		String separator = "";

		/**
		 *  prima parte: 210c se valorizzato
		 */
		List<VariableField> marcField210List = record.getVariableFields("210");
		for (VariableField vf : marcField210List) {
			DataField marcField210 = (DataField) vf;
			List<Subfield> subfield210cList = marcField210.getSubfields('c');
			for (Subfield subfield : subfield210cList) {
				if (subfield.getData() != null && !"".equals(subfield.getData())) {
					result.add(subfield.getData());
				}
			}
		}

		/**
		 *  seconda parte: 700-750 a,b,c,d,e,f,g (separati da spazio) con $4 650 o 750
		 */
		int startTag = 700;
		int endTag = 750;
		String subfldTags = "[a|b|c|d|e|f|g]";
		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			List<VariableField> marcFieldList = record.getVariableFields(String.valueOf(tag));
			if (!marcFieldList.isEmpty()) {
				Pattern subfieldPattern = Pattern.compile(subfldTags.length() == 0 ? "." : subfldTags);
				for (VariableField vf : marcFieldList) {
					DataField marcField = (DataField) vf;
					Subfield checkSubfield = marcField.getSubfield('4');
					if (checkSubfield != null && ("650".equalsIgnoreCase(checkSubfield.getData()) || "750".equalsIgnoreCase(checkSubfield.getData()))) {
						StringBuilder buffer = new StringBuilder("");
						List<Subfield> subfields = marcField.getSubfields();
						for (Subfield subfield : subfields) {
							Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
							if (matcher.matches()) {
								if (buffer.length() > 0)
									buffer.append(separator != null ? separator : "");
								buffer.append(subfield.getData());
							}
						}
						if (buffer.length() > 0)
							result.add(buffer.toString());
					}
				}
			}
		}

		return result;
	}

	/** 
	 * tag 410 $1 -> se contenuto inizia per 
	 * 		200 -> prendo $a, $e e $f
	 * 		0 200 -> prendo $a, $e e $f
	 * 
	 */
	public Set<String> getCollezione(final Record record) {
	  return getCollezionePre(record, true);
	}
	public Set<String> getCollezione2(final Record record) {
	  return getCollezionePre(record, false);
	}
	public Set<String> getCollezionePre(final Record record, boolean after_pre) {
		Set<String> result = new LinkedHashSet<String>();

		List<VariableField> field = (List<VariableField>) record.getVariableFields("410");
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			DataField dataField = (DataField) iterator.next();

			List<Subfield> subflds = dataField.getSubfields('1');
			for (Iterator<Subfield> iteratorSubflds = subflds.iterator(); iteratorSubflds.hasNext();) {
				Subfield subfield = (Subfield) iteratorSubflds.next();

				// se inizia per 200 o per 0 200 prendo tutti i $a
				if (subfield.getData().startsWith("200") || subfield.getData().startsWith("0 200")) {

					List<Subfield> subflds$a = dataField.getSubfields('a');
					for (Iterator<Subfield> iterator2 = subflds$a.iterator(); iterator2.hasNext();) {
						Subfield temp = (Subfield) iterator2.next();
						String data = temp.getData();
						if (!after_pre) {
						  data = CleanNoSort.clean(data);
                          data = String.valueOf(foldToASCII(data.toCharArray(), data.length())).trim();
						}
						result.add(data);
					}

					List<Subfield> subflds$e = dataField.getSubfields('e');
					for (Iterator<Subfield> iterator2 = subflds$e.iterator(); iterator2.hasNext();) {
						Subfield temp = (Subfield) iterator2.next();
						result.add(temp.getData());	
					}

					List<Subfield> subflds$f = dataField.getSubfields('f');
					for (Iterator<Subfield> iterator2 = subflds$f.iterator(); iterator2.hasNext();) {
						Subfield temp = (Subfield) iterator2.next();
						result.add(temp.getData());	
					}
				}
			}
		}
		if (after_pre)
		    result = cleanPretitolo(result,"1"); // clean del pretitolo

		return result;
	}


	public Set<String> getCollBid(final Record record) {
		Set<String> result = new LinkedHashSet<String>();


		int startTag = 461;
		int endTag = 463;


		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {

			List<VariableField> field = (List<VariableField>) record.getVariableFields(String.valueOf(tag));
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				Subfield subfield = dataField.getSubfield('1');
				String data = subfield.getData();
				if (data.startsWith("001")) {
					String bid = data.substring(3);
					result.add(bid);
				}
			}
		}

		return result;
	}

	public Set<String> getCollBidLevel(final Record record,String tag, String level) {
		Set<String> result = new LinkedHashSet<String>();
		String leader = record.getLeader().toString();
		char levelrec = leader.charAt(7);
		if (levelrec == level.charAt(0)) {
			if (tag.contains(":")) {
				String[] tags = tag.split(":");
				for (int i=0;i< tags.length;i++)
					result.addAll(getCollBid_$(record, tags[i]));
			}
			else
				return getCollBid_$(record,tag);
		}

		return result;
	}
	public Set<String> getCollBid_$(final Record record, String tag) {
		Set<String> result = new LinkedHashSet<String>();

		List<VariableField> field = (List<VariableField>) record.getVariableFields(String.valueOf(tag));
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			DataField dataField = (DataField) iterator.next();
			Subfield subfield = dataField.getSubfield('1');
			if (subfield == null)
				continue;
			String data = subfield.getData();
			if (data.startsWith("001")) {
				String bid = data.substring(3);
				result.add(bid);
			}
		}

		return result;
	}
	/*
	 * 411-499 1200 a=COLLTIT
	 */
	public Set<String> getCollTit(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		int startTag = 411;
		int endTag = 499;
		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			result.addAll(getCollTit_$(record, String.valueOf(tag)));
		}

		result = cleanPretitolo(result,"1"); // clean del pretitolo

		return result;
	}

	public Set<String> getCollTit_$(final Record record, String tag) {

		return getCollTit_$(record, tag, null,true);

	}
	public String getCollOrd(final Record record) {

		String result = getCollOrd_$(record, "461");
		if (result == null || result.length() == 0)
		  result = getCollOrd_$(record, "462");
		return result;
	}
	public String getCollOrd_$(final Record record, String tag) {
		String result =null;
		List<VariableField> marcFieldList = record.getVariableFields(tag);
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			boolean good = false;


				List<Subfield> subfields =  marcField.getSubfields();
				StringBuilder buffer = new StringBuilder("");
				for (Subfield subfield : subfields) {
					char code = subfield.getCode();
					String subfieldString = subfield.toString();
					if (subfieldString.startsWith("$1200"))
						good = true;
					if (good) {
						switch (code) {
						case 'v':
							buffer.append(subfield.getData());
							break;
						default:
							break;
						}
					}
				}
				if (buffer.length() > 0)
				   result = buffer.toString().trim();
			}
	//	logger.warn("Record" +   record.getVariableField("001").toString() + result);

		try {
		    if (result != null) {
			 if (result.indexOf("v.") > 0)
				   result = result.replaceAll("v.", "");
			 if (result.indexOf("-") > 0)
				   result = result.replaceAll("-", ".");
			 if (result.indexOf("(") > 0)
					result = result.substring(0, result.indexOf("("));
			 if (result.indexOf("/") > 0)
					result = result.replaceAll("/", ".");
		    }
		} catch (NumberFormatException nfe) {
			logger.warn("Record" +   record.getVariableField("001").toString() + " non ordinabile nella madre : $v = " + result);
			result = null;
		}

		return result;
	}
	public Set<String> getCollTit_$(final Record record, String tag, String ind1, Boolean clean_pretit) {
		Set<String> result = new LinkedHashSet<String>();
		List<VariableField> marcFieldList = record.getVariableFields(tag);
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;

			boolean firstA = true;

			boolean parentesiB = false;
			int idxLastB = 0;
			boolean firstB = true;
			boolean good = false;


			List<Subfield> subfields =  marcField.getSubfields();
			StringBuilder buffer = new StringBuilder("");
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();
				String subfieldString = subfield.toString();
				if (ind1 == null && subfieldString.startsWith("$1200")) 
					good = true;
				else if (ind1 != null && subfieldString.startsWith("$1200"+ ind1))
					good = true;
				if (subfieldString.startsWith("$17")) good = false;

				if (good) {
					switch (code) {

					case 'a':
						if (firstA) {
							if (clean_pretit)
								buffer.append(cleanPretitolo(subfield.getData()));
							else
								buffer.append(subfield.getData().replaceAll("\u001bH", "<<").replaceAll("\u001bI", ">>"));
							firstA = false;
						} else {
							if (clean_pretit)
								buffer.append(" ; ").append(cleanPretitolo(subfield.getData()));
							else
								buffer.append(" ; ").append(subfield.getData().replaceAll("\u001bH", "<<").replaceAll("\u001bI", ">>"));
						}
						break;

					case 'b':
						if (firstB) {
							buffer.append(" [").append(subfield.getData());
							firstB = false;
							parentesiB = true;
						} else {
							buffer.append(" ").append(subfield.getData());
							idxLastB = buffer.length();
						}
						break;

					case 'c':
						buffer.append(" . ").append(subfield.getData());
						break;

					case 'd':
						buffer.append(" = ").append(subfield.getData());
						break;

					case 'e':
						buffer.append(" : ").append(subfield.getData());
						break;

					case 'f':
						buffer.append(" / ").append(subfield.getData());
						break;

					case 'g':
						buffer.append(" ; ").append(subfield.getData());
						break;

					default:
						break;
					}	
				}

				// inserisco la parentesi dopo l'ultima b inserita
				if (parentesiB) {
					buffer.insert(idxLastB, "] ");
				}
			}
			if (buffer.length() > 0) result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
		}
		//		if (clean_pretit)
		//		   result = cleanPretitolo(result); // clean del pretitolo : gi√† fatto per ogni $a
		return result;
	}

	public Set<String> getTitNav_$(final Record record, String tag) {
		Set<String> result = new LinkedHashSet<String>();
		List<VariableField> marcFieldList = record.getVariableFields(tag);
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;

			boolean firstA = true;

			boolean good = false;


			List<Subfield> subfields =  marcField.getSubfields();
			StringBuilder buffer = new StringBuilder("");
			for (Subfield subfield : subfields) {
				char code = subfield.getCode();
				String subfieldString = subfield.toString();
				if ( subfieldString.startsWith("$1200")) 
					good = true;
				if (subfieldString.startsWith("$17")) good = false;

				if (good) {
					switch (code) {

					case 'a':
						if (firstA) {

							buffer.append(cleanPretitolo(subfield.getData()));
							firstA = false;
						} else {
							buffer.append(" ; ").append(cleanPretitolo(subfield.getData()));
						}
						break;


					case 'e':
						buffer.append(" : ").append(subfield.getData());
						break;


					default:
						break;
					}	
				}

			}
			if (buffer.length() > 0) {
				String cleanedBuff = buffer.toString().replaceAll("\\s*\\.?\\s*-?\\s*$", "");
				result.add(String.valueOf(foldToASCII(cleanedBuff.toCharArray(), cleanedBuff.length())).trim());
			}
		}
		return result;
	}
	/*
	 	altritit_tip_A = 517$a quando $e = "APP"
		altritit_tip_I = 517$a quando $e = "INC"
		altritit_tip_L = 517$a quando $e = "ALT" 
		altritit_tip_D = 517$a quando $e = "OLE"
		altritit_tip_O = 517$a quando $e = "OPA"
		altritit_tip_8 = 517$a quando $e = "P"
		altritit_tip_V = 517$a quando $e = ""
	 */
	public Set<String> getAltritit_Tip_$(final Record record, String $tip) {
		Set<String> result = new LinkedHashSet<String>();

		DataField dataField = (DataField) record.getVariableField("517");
		if (dataField == null) {
			return null;
		}

		Subfield subfield = dataField.getSubfield('e');
		if (subfield == null) {
			return null;
		}

		String data = subfield.getData();

		Subfield value = dataField.getSubfield('a');

		if ("APP".equalsIgnoreCase(data) && "A".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("INC".equalsIgnoreCase(data) && "I".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("ALT".equalsIgnoreCase(data) && "L".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("OLE".equalsIgnoreCase(data) && "D".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("OPA".equalsIgnoreCase(data) && "O".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("P".equalsIgnoreCase(data) && "8".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}
		if ("".equalsIgnoreCase(data) && "V".equalsIgnoreCase($tip)) {
			result.add(value.getData());
		}

		result = cleanPretitolo(result,"0"); // clean del pretitolo

		return result;
	}

	/*
	 * 463 a con header pos 7 = a
	 */
	public Set<String> getHosti(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		String leader =record.getLeader().toString();
		char test = leader.charAt(7);
		if (test == 'a') {
			List<VariableField> marcFieldList = record.getVariableFields("463");
			for (Iterator<VariableField> iterator = marcFieldList.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields('a');
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					result.add(subfield.getData());
				}
			}
			marcFieldList = record.getVariableFields("461");
			for (Iterator<VariableField> iterator = marcFieldList.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields('a');
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					result.add(subfield.getData());
				}
			}
		}
		return result;
	}

	/*
	 * 215 a a a : c : c : c ; d ; d ; d ; d + e + e + e + e
	 */
	public Set<String> getDescr(final Record record) {
		Set<String> result = new LinkedHashSet<String>();

		List<VariableField> marcFieldList = record.getVariableFields("215");
		for (Iterator<VariableField> iterator = marcFieldList.iterator(); iterator.hasNext();) {
			DataField dataField = (DataField) iterator.next();

			StringBuilder buffer = new StringBuilder();

			List<Subfield> subfields =  dataField.getSubfields();
			for (Subfield subfield : subfields) {

				char code = subfield.getCode();
				switch (code) {
				case 'a':
					if (buffer.length() > 0) buffer.append(" ");
					buffer.append(subfield.getData());
					break;
				case 'c':
					if (buffer.length() > 0) buffer.append(" : ");
					buffer.append(subfield.getData());
					break;
				case 'd':
					if (buffer.length() > 0) buffer.append(" ; ");
					buffer.append(subfield.getData());
					break;	
				case 'e':
					if (buffer.length() > 0) buffer.append(" + ");
					buffer.append(subfield.getData());
					break;
				default:
					break;
				}

			}

			result.add(buffer.toString());
		}

		return result;
	}


	/*
	 * header pos= 7  se pos 9 = '  ' altrimenti pos 9 (se natura pos 7 = 'm' e 200 pos 0 = '0' allora natura  = 'w')
	 */
	public String getNatura(final Record record) {
		String natura = null;

		String leader = record.getLeader().toString();
		if (leader.charAt(9) != ' ') {
			natura = String.valueOf(leader.charAt(9));
		} else {
			DataField dataField = (DataField) record.getVariableField("200");
			if (leader.charAt(7) == 'm' && dataField != null && dataField.getIndicator1() == '0') {
				natura = "w";
			} else {
				natura = String.valueOf(leader.charAt(7));	
			}
		} 
		return natura;
	}

	/*
	 * 710-729 a,b,c,d,f,g (separati da spazio)  con indicatore 1 = 0 ente
	 * 
	 * 710-729 a,b,c,d,f,g (separati da spazio)  con indicatore 1 = 1 congresso
	 */

	public Set<String> getEnteOrCongresso(final Record record, String pInd1) {
		Set<String> result = new LinkedHashSet<String>();
		char ind1 = pInd1.charAt(0);
		Pattern subfieldPattern = Pattern.compile("[a|b|c|d||e|f|g]");
		int startTag = 710;
		int endTag = 729;
		// itero sui tag
		StringBuilder buffer = null;
		for (int tag = startTag; tag <= endTag; tag++) {
			List<VariableField> field = (List<VariableField>) record.getVariableFields(String.valueOf(tag));
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				buffer = new StringBuilder();

				DataField dataField = (DataField) iterator.next();
				if (dataField.getIndicator1() == ind1) {
					List<Subfield> subfields = dataField.getSubfields();
					for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
						Subfield subfield = (Subfield) iterator2.next();
						Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
						if (matcher.matches()) {
							if (buffer.length() > 0) buffer.append("");
							buffer.append(cleanPretitolo(subfield.getData()));
						}
					}
				}
				if (buffer.length() > 0)
					result.add(buffer.toString());

			}
		}
		buffer = new StringBuilder();
		List<VariableField> field = (List<VariableField>) record.getVariableFields("791");
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			buffer = new StringBuilder();
			DataField dataField = (DataField) iterator.next();
			if (dataField.getIndicator1() == ind1) {
				List<Subfield> subfields = dataField.getSubfields();
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
					if (matcher.matches()) {
						if (buffer.length() > 0) buffer.append("");
						buffer.append(cleanPretitolo(subfield.getData()));
					}
				}
			}
			if (buffer.length() > 0)
				result.add(buffer.toString());

		}
		return result;
	}




	/*
	 * 70x-71x-72x-73x-74x con x = 3|2|1  ‚Üí *                a,b,c,d,e,f,g (separati da spazio)
	 */
	public Set<String> getNome_liv_$(final Record record, String x) {
		Set<String> result = new LinkedHashSet<String>();
		Pattern subfieldPattern = Pattern.compile("[a|b|c|d|e|f|g]");
		String startTagString = "70".concat(x);
		String endTagString = "74".concat(x);
		int startTag = Integer.valueOf(startTagString);
		int endTag = Integer.valueOf(endTagString);
		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			if (!String.valueOf(tag).endsWith(x) )	continue;
			List<VariableField> field = (List<VariableField>) record.getVariableFields(String.valueOf(tag));
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				StringBuilder buffer = new StringBuilder();
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields();
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
					if (matcher.matches()) {
						buffer.append(cleanPretitolo(subfield.getData()));
					}

				}
				if (buffer.length() > 0)
					result.add(buffer.toString());
			}
		}
		return result;
	}


	/*
	 * 	
	 */

	public String getPretitolo(final Record record) {
		List<VariableField> field = (List<VariableField>) record.getVariableFields("200");
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			DataField dataField = (DataField) iterator.next();
			List<Subfield> subfields = dataField.getSubfields('a');
			for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
				Subfield subfield = (Subfield) iterator2.next();
				String subValue = subfield.getData();

				return getPretitolo(subValue);
			}
		}
		return null;
	}

	private String getPretitolo(String value) {
		if (value != null && value.indexOf(START_PRETITOLO) != -1 && value.indexOf(END_PRETITOLO) != -1) {
			int beginIndex = value.indexOf(START_PRETITOLO) + START_PRETITOLO.length();
			int endIndex = value.indexOf(END_PRETITOLO);
			return value.substring(beginIndex, endIndex);
		}
		return null;
	}
	public String getPreautore(final Record record) {
		List<VariableField> marcFieldList = record.getVariableFields("710");
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;
			List<Subfield> subfields = marcField.getSubfields();
			for (Subfield subfield : subfields) {
				if (subfield.getCode() != '3' && subfield.getCode() != '4') {
					String subValue = getPretitolo(subfield.getData());
					if (subValue != null  && subValue.trim().length() > 0)
						return subValue;
				}
			}
		}

		return null;
	}
	public String getUnimarcBase64(final Record record) {
		record.getLeader().setCharCodingScheme(' ');  // annulla il charset schema perch√® altrimenti non √® standard
		ByteArrayOutputStream baos = new ByteArrayOutputStream(); 

		MarcStreamWriter marcStreamWriter = new MarcStreamWriter(baos, "UTF-8");
		marcStreamWriter.write(record);
		marcStreamWriter.close();

		try {
			baos.flush();
			baos.close();
		} catch (IOException e) {
			e.printStackTrace();
		}


		String unimarcBase64 = new String(Base64.encodeBase64(baos.toByteArray()));

		return unimarcBase64;
	}
	 /* public String getTitolo(final Record record, String tagStr, String separator) {
		String result = getFieldVals(record, tagStr, separator);
		result= cleanPretitolo(result);
		result = String.valueOf(foldToASCII(result.toCharArray(), result.length())).trim();
		return result;
	} */ 
	 public String getTitolo(final Record record, String tagStr, String separator) {
         return getTitolo2(record,tagStr,separator,"1");
     }
     public String getTitolo2(final Record record, String tagStr, String separator, String pre) {
         String result = getFieldVals(record, tagStr, separator);
         if (pre == null || pre.length() == 0 || "1".equals(pre))
            result= cleanPretitolo(result);
         else
        //   result = result.replaceAll(START_PRETITOLO,"").replaceAll(END_PRETITOLO, "");
        	 result = CleanNoSort.clean(result);
         result = String.valueOf(foldToASCII(result.toCharArray(), result.length())).trim();
         return result;
    }
	public Set<String> getDataPubF(final Record record, String tagStr, String separator) {
		Set<String> values = getFieldList(record, tagStr);
		Set<String> result = new LinkedHashSet<String>();
		Iterator<String> iterator = values.iterator(); 
		String type = "";
		String datada = "";
		String dataa = "";
		if (iterator.hasNext()) 
			type = (String) iterator.next();
		if (iterator.hasNext()) 
			datada = ((String) iterator.next()).replaceAll(" ", "");
		if (iterator.hasNext()) 
			dataa = ((String) iterator.next()).replaceAll(" ", "");
		if (!validDate(datada))
			datada = "";
		if (!validDate(dataa))
			dataa = "";
		if (type.equalsIgnoreCase("a")  && datada.length() == 4) {
			result.add(datada.concat("-"));
		}
		else if (type.equalsIgnoreCase("b") || type.equalsIgnoreCase("g")  || 
				type.equalsIgnoreCase("d") || type.equalsIgnoreCase("f") ) {
			if (dataa.length() == 4)
				result.add(datada.concat("-").concat(dataa));
			else
				result.add(datada);
		}
		else if (type.equalsIgnoreCase("e") || type.equalsIgnoreCase("r")) {
			if (datada.length() == 4)
				result.add(datada);
			if (dataa.length() == 4)
				result.add(dataa);	
		}
		return result;
	}
	public String getDataDa(final Record record, String tagStr, String separator) {
		Set<String> values = getFieldList(record, tagStr);
		Iterator<String> iterator = values.iterator(); 
		String datada = "";
		if (iterator.hasNext()) {
		}
		if (iterator.hasNext()) 
			datada = ((String) iterator.next()).replaceAll(" ", "");

		datada= replaceDate(datada, '0');
		if (validDate(datada))
			return datada;
		return null;
	}
	public Set<String> getIntVal(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();

		Set<String> values = getFieldList(record, tagStr);
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {

			String val = (String) iterator.next();
			val = val.replaceAll("[\\,|\\.]", "");
			try {
				int valI = Integer.parseInt(val);
				result.add(valI +"");
			} catch (NumberFormatException nfe) { 
				continue;
			}
		}
		return result;
	}
	public Set<String> getCordinata(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();

		Set<String> values = getFieldList(record, tagStr);
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {

			String val = (String) iterator.next();
			if (val == null || (val.length() != 8 && val.length() != 7))
				continue;

			if (val.toLowerCase().startsWith("s") || val.toLowerCase().startsWith("o"))
				val = val.toLowerCase().replace("s", "-").replace("o", "-");
			else if (val.startsWith(" "))
				val = "0";
			else
				val = val.substring(1);
			try {
				int valI = Integer.parseInt(val);
				result.add(valI +"");
			} catch (NumberFormatException nfe) { 
				continue;
			}
		}
		return result;
	}
	public String getDataA(final Record record, String tagStr, String separator) {
		String leader = record.getLeader().toString();
		char level = leader.charAt(7);
		Set<String> values = getFieldList(record, tagStr);
		String result = null;
		Iterator<String> iterator = values.iterator(); 
		String type = "";
		String datada = "";
		String dataa = "";
		if (iterator.hasNext()) 
			type = (String) iterator.next();
		if (iterator.hasNext()) 
			datada = ((String) iterator.next()).replaceAll(" ", "");
		if (iterator.hasNext()) 
			dataa = ((String) iterator.next()).substring(4).replaceAll(" ", "");
		if (type.equalsIgnoreCase("b") || type.equalsIgnoreCase("g"))
		   dataa = replaceDate(dataa, '9');
		if (type.equalsIgnoreCase("e") || type.equalsIgnoreCase("r"))
			datada = replaceDate(datada, '9');
		else if (!(type.equalsIgnoreCase("f")))
			datada = replaceDate(datada, '0');
		if (!validDate(datada))
			datada = "";
		if (!validDate(dataa))
			dataa = "";
		if ((type.equalsIgnoreCase("b") || type.equalsIgnoreCase("g")  ||  type.equalsIgnoreCase("f")) && dataa.length() == 4) {
			result = dataa;
		}
		else if ((type.equalsIgnoreCase("d") || type.equalsIgnoreCase("e") || type.equalsIgnoreCase("r") || (type.equalsIgnoreCase("f") && level == 'm')) && datada.length() == 4  ) {
			result = datada;
		}
		else if ((type.equalsIgnoreCase("a") || type.equalsIgnoreCase("b") || type.equalsIgnoreCase("c") ||
				type.equalsIgnoreCase("g")  ||  (type.equalsIgnoreCase("f") && level != 'm')) && datada.length() == 4) {
			result = "9999";
		}
		return result;
	}
	public String getDataA2(final Record record, String tagStr, String separator) {
		Set<String> values = getFieldList(record, tagStr);
		String result = null;
		Iterator<String> iterator = values.iterator(); 
		String type = "";
		String datada = "";
		String dataa = "";
		if (iterator.hasNext()) 
			type = (String) iterator.next();
		if (iterator.hasNext()) 
			datada = ((String) iterator.next()).replaceAll(" ", "");
		if (iterator.hasNext()) 
			dataa = ((String) iterator.next()).replaceAll(" ", "");
		if (type.equalsIgnoreCase("e"))
			dataa = replaceDate(dataa, '9');

		if (!validDate(datada))
			datada = "";
		if (!validDate(dataa))
			dataa = "";

		if ((type.equalsIgnoreCase("e") || type.equalsIgnoreCase("r")) && dataa.length() == 4  ) {
			result = dataa;
		}
		return result;
	}
	public String getDataDa2(final Record record, String tagStr, String separator) {
		Set<String> values = getFieldList(record, tagStr);
		String result = null;
		Iterator<String> iterator = values.iterator();
		String type = "";
		String datada = "";
		String dataa = "";
		if (iterator.hasNext())
			type = (String) iterator.next();
		if (iterator.hasNext())
			datada = ((String) iterator.next()).replaceAll(" ", "");
		if (iterator.hasNext())
			dataa = ((String) iterator.next()).replaceAll(" ", "");
		if (type.equalsIgnoreCase("e"))
			dataa = replaceDate(dataa, '0');

	//	logger.error("getDataDa2 datada " +  datada);
	//	logger.error("getDataDa2 dataa " +  dataa);

		if (!validDate(datada))
			datada = "";
		if (!validDate(dataa))
			dataa = "";

		if ((type.equalsIgnoreCase("e") || type.equalsIgnoreCase("r")) && dataa.length() == 4  ) {
			result = dataa;
	    }
	//	logger.error("getDataDa2 result " +  result);
		return result;
	}

	// 700abcdfg:701abcdfg:702abcdfg:703abcdfg:704abcdfg:705abcdfg:706abcdfg:707abcdfg:708abcdfg:709abcdfg, " "
	public Set<String> getPersona(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		Pattern subfieldPattern = Pattern.compile("[a|b|c|d|e|f|g]");
		int startTag = 700;
		int endTag = 709;
		// itero sui tag
		for (int tag = startTag; tag <= endTag; tag++) {
			List<VariableField> field = (List<VariableField>) record.getVariableFields(String.valueOf(tag));
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				StringBuilder buffer = new StringBuilder();
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields();
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
					if (matcher.matches()) {
						// if (buffer.length() > 0) buffer.append(" ");
						buffer.append(cleanPretitolo(subfield.getData()));
					}
				}
				result.add(buffer.toString());
			}
		}
		List<VariableField> field = (List<VariableField>) record.getVariableFields("790");
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			StringBuilder buffer = new StringBuilder();
			DataField dataField = (DataField) iterator.next();
			List<Subfield> subfields = dataField.getSubfields();
			for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
				Subfield subfield = (Subfield) iterator2.next();
				Matcher matcher = subfieldPattern.matcher("" + subfield.getCode());
				if (matcher.matches()) {
					// if (buffer.length() > 0) buffer.append(" ");
					buffer.append(cleanPretitolo(subfield.getData()));
				}
			}
			result.add(buffer.toString());
		}

		return result;
	}
	public Set<String> getBiblioteca(final Record record) {

		Set<String> result = new LinkedHashSet<String>();


		String bid = ((ControlField) record.getVariableField("001")).getData();
		if (bid.startsWith("SBFL") || bid.startsWith("000")) {	
			Set<String> biblios = getFieldList(record, "950a");
			for (Iterator<String> iterator = biblios.iterator() ; iterator.hasNext();) {
				String val = iterator.next();
				if (val.contains("Biblioteca Civica di Finale Ligure"))
					result.add("IT-SV0021");
				else if (val.contains("Biblioteca Civica di Calice Ligure"))
					result.add("IT-SV0097");
				else if (val.contains("Biblioteca civica di Magliolo"))
					result.add("GB00000555");
				else if (val.contains("Biblioteca San Lorenzo Varigotti"))
					result.add("GB00000531");
				else if (val.contains("Biblioteca Civica \"Camillo Sbarbaro\""))
					result.add("IT-SV0045");


			}
			return result;
		}

		if (props_bib != null && props_bib.size() > 0) {
			if (props_bib.getProperty(bid) != null) {
				String[] elements = props_bib.getProperty(bid).split(" ");
				for (int i=0; i<elements.length; i++) {
					if (elements[i] != null && elements[i].length() > 0)
						result.add(elements[i]);
				}
			}
		}
		return result;
	}

	public Set<String> getProvincia(final Record record, String tagStr) {

		Set<String> result = new LinkedHashSet<String>();
		if (props_prov != null && props_prov.size() > 0) {
			Set<String> values = getFieldList(record, tagStr);
			for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
				String val = (String)iterator.next();
				if (val != null && val.trim().length()>0 && props_prov.getProperty(val.trim()) != null && props_prov.getProperty(val.trim()).length() > 0)
					result.add(props_prov.getProperty(val.trim()));
			}
		}
		if (props_bib != null && props_bib.size() > 0 && props_prov != null && props_prov.size() > 0) {
			String bid = ((ControlField) record.getVariableField("001")).getData();
			if (props_bib.getProperty(bid) != null) {
				String[] elements = props_bib.getProperty(bid).split(" ");

				for (int i=0; i<elements.length; i++) {
					if (elements[i] != null && elements[i].length() > 0 && props_prov.getProperty(elements[i]) != null && props_prov.getProperty(elements[i]).length() > 0)
						result.add(props_prov.getProperty(elements[i]));
				}
			}
		}
		return result;
	}
	public Set<String> getDataBib(final Record record, String bib) {

		Set<String> result = new LinkedHashSet<String>();
		Set<String> values = getFieldList(record, "850a");
		Set<String> dates = getFieldList(record, "950i");
		if (values.size() != dates.size())
			return null;
		Iterator<String> dateIteraror = dates.iterator();
		for (Iterator<String> iterator = values.iterator() ; iterator.hasNext();) {
			String val = (String)iterator.next();
			String date = (String) dateIteraror.next();
			if (bib.equalsIgnoreCase(val))
				result.add(date);
		}
		return result;
	}

	public Set<String> getFieldListPretitCleaned(final Record record, String tagStr, String fold) {
		Set<String> result = getFieldList(record, tagStr);
		result = cleanPretitolo(result,fold);
		return result;
	}

	public Set<String> getLuogoCleaned(final Record record, String tagStr) {
		Set<String> result = getFieldList(record, tagStr);
		result = cleanLuogo(result);
		return result;
	}

	public Set<String> getEditoreCleaned(final Record record, String tagStr) {
		Set<String> result = getFieldList(record, tagStr);
		result = cleanEditore(result);
		return result;
	}

	// 100[0-7]
	public Set<String> getDatadb(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		List<VariableField> field = (List<VariableField>) record.getVariableFields("100");
		for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
			DataField dataField = (DataField) iterator.next();
			String stringDatafield = dataField.toString();
			if (stringDatafield != null && stringDatafield.length() > 0) {
				result.add(stringDatafield.substring(0, 7));
			}
		}
		return result;
	}


	// content = 105[0]:105[1]:105[2]
	public Set<String> getContent(final Record record) {
		Set<String> result = new LinkedHashSet<String>();
		if( "E".equalsIgnoreCase(((ControlField) record.getVariableField("001")).getData().substring(8, 9))) {
			List<VariableField> field = (List<VariableField>) record.getVariableFields("114");
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields('a');
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					String stringDatafield = subfield.toString();
					if (stringDatafield != null && stringDatafield.length() > 8) {
						result.add(stringDatafield.substring(11,13));
						result.add(stringDatafield.substring(13,15));
						result.add(stringDatafield.substring(15,17));
						result.add(stringDatafield.substring(17,19));
					}
				}

			}
		} else {
			List<VariableField> field = (List<VariableField>) record.getVariableFields("105");
			for (Iterator<VariableField> iterator = field.iterator(); iterator.hasNext();) {
				DataField dataField = (DataField) iterator.next();
				List<Subfield> subfields = dataField.getSubfields('a');
				for (Iterator<Subfield> iterator2 = subfields.iterator(); iterator2.hasNext();) {
					Subfield subfield = (Subfield) iterator2.next();
					String stringDatafield = subfield.toString();
					if (stringDatafield != null && stringDatafield.length() > 3) {
						result.add(stringDatafield.substring(6,7));
						result.add(stringDatafield.substring(7,8));
						result.add(stringDatafield.substring(8,9));
						result.add(stringDatafield.substring(9,10));
						if ("1".equals(stringDatafield.substring(10,11)))
							result.add(stringDatafield.substring(10,11));
					}
				}

			}
		}
		return result;
	}

	public Set<String> getCollTitFaparte_$(final Record record, String tag, String ind1, Boolean clean_pretit) {
		Set<String> result = new LinkedHashSet<String>();
		List<VariableField> marcFieldList = record.getVariableFields(tag);
		for (VariableField vf : marcFieldList) {
			DataField marcField = (DataField) vf;

			boolean firstA = true;

			boolean parentesiB = false;
			int idxLastB = 0;
			boolean firstB = true;
			boolean good = false;


				List<Subfield> subfields =  marcField.getSubfields();
				StringBuilder buffer = new StringBuilder("");
				for (Subfield subfield : subfields) {
					char code = subfield.getCode();
					String subfieldString = subfield.toString();
					if (ind1 == null && subfieldString.startsWith("$1200"))
						good = true;
					else if (ind1 != null && subfieldString.startsWith("$1200"+ ind1))
						good = true;
					if (subfieldString.startsWith("$17")) good = false;

					if (good) {
						switch (code) {

						case 'a':
							if (firstA) {
								if (clean_pretit)
								buffer.append(cleanPretitolo(subfield.getData()));
								else
									buffer.append(subfield.getData().replaceAll(START_PRETITOLO, "<<").replaceAll(END_PRETITOLO, ">>"));
								firstA = false;
							} else {
								if (clean_pretit)
									buffer.append(" ; ").append(cleanPretitolo(subfield.getData()));
								else
									buffer.append(" ; ").append(subfield.getData().replaceAll(START_PRETITOLO, "<<").replaceAll(END_PRETITOLO, ">>"));
							}
							break;

						case 'b':
							if (firstB) {
								buffer.append(" [").append(subfield.getData());
								firstB = false;
								parentesiB = true;
							} else {
								buffer.append(" ").append(subfield.getData());
								idxLastB = buffer.length();
							}
							break;

						case 'c':
							buffer.append(" . ").append(subfield.getData());
							break;

						case 'd':
							buffer.append(" = ").append(subfield.getData());
							break;

						case 'e':
							buffer.append(" : ").append(subfield.getData());
							break;

						default:
							break;
						}
					}

					// inserisco la parentesi dopo l'ultima b inserita
					if (parentesiB) {
						buffer.insert(idxLastB, "] ");
					}
				}
				if (buffer.length() > 0) result.add(String.valueOf(foldToASCII(buffer.toString().toCharArray(), buffer.length())).trim());
			}
//		if (clean_pretit)
//		   result = cleanPretitolo(result); // clean del pretitolo : gi√† fatto per ogni $a
		return result;
	}
	public Set<String> getFaPartediTit(final Record record) {

		Set<String> result = new LinkedHashSet<String>();
		// itero sui tag
		String leader = record.getLeader().toString();
		char ger = leader.charAt(8);
		char level = leader.charAt(7);

		if ('2' != ger)
			return null;
		int startTag = 461;
		int endTag = 463;
		if ('a' == level || 'm' == level);
		else
			startTag = 464;
		for (int tag = startTag; tag <= endTag; tag++) {
			if ('a' == level && tag == 462)
				continue;
			result.addAll(getCollTitFaparte_$(record, String.valueOf(tag),"1", false));
		}
		return result;
	}

	public Set<String> getFaPartedi(final Record record) {

		Set<String> result = new LinkedHashSet<String>();
		// itero sui tag
		String leader = record.getLeader().toString();
		char ger = leader.charAt(8);
		char level = leader.charAt(7);

		if ('2' != ger)
			return null;
		int startTag = 461;
		int endTag = 463;
		if ('a' == level || 'm' == level);
		else
			startTag = 464;
		for (int tag = startTag; tag <= endTag; tag++) {
			if ('a' == level && tag == 462)
				continue;
			result.addAll(getCollTit_$(record, String.valueOf(tag),"1", false));
		}
		//		if (many > 1)
		//			logger.debug("Record" +   record.getVariableField("001").toString() + " con pi√π fa parte di ");
		return result;
	}

	public Set<String> getIncipit(final Record record, String tagStr, String soloLett) {
		Set<String> values = getFieldList(record, tagStr);
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = (String) iterator.next();
			if (value.length() > 0 && "0".equals(soloLett))
				result.add (String.valueOf(foldToASCII(value.toCharArray(), value.length())).trim());
			char[] input = value.toCharArray();
			char []output = new char[input.length];
			int j =0;
			for (int pos = 0 ; pos < input.length ; ++pos) {
				final char c = input[pos];
				if (c >= 'A' && c <= 'Z')
					output[j++] = c;
			}
			result.add(String.valueOf(output).trim());
		}
		return result;
	}
	public String getDataUpdate(final Record record, String tagStr, String pattern) {

		Set<String> values = getFieldList(record, tagStr);

		Iterator<String> iterator = values.iterator(); 
		while (iterator.hasNext()) {
			String date = (String) iterator.next();
			try {
				return DatetimeConversion.getSolrDatetime(date, pattern);
			} catch (Exception e) {
				// se va in exception non aggiungo nulla
				// e.printStackTrace();
			}
		}

		return null;
	}

	public Set<String> getCleanData(final Record record, String tagStr) {
		Set<String> result = new LinkedHashSet<String>();

		Set<String> values = getFieldList(record, tagStr);

		Iterator<String> iterator = values.iterator(); 
		while (iterator.hasNext()) {
			String data = (String) iterator.next();
			try {
				Integer.valueOf(data);
				result.add(data);
			} catch (Throwable ex) {

			}
		}

		return result;
	}
	public Set<String> getRaccolte(final Record record) {

		//		logger.warn("getRaccolte " );
		if (props_raccolte == null) return null;
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<Object> iter = props_raccolte.keySet().iterator(); iter.hasNext();) {
			String key = (String)iter.next();
			//		 logger.warn("Raccolte key " +   key  + " val " +  props_raccolte.getProperty(key));
			String[] elements = props_raccolte.getProperty(key).split(" ");
			if (key.indexOf("NOKEY")> 1 )
				key = key.substring(0, key.indexOf("NOKEY"));
			Set<String> values = null;
			if (elements.length == 3) {
				values = getFieldList(record, elements[0]);
				for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
					String valmarc = (String)iterator.next();
					if (check_value_raccolte(valmarc,elements[1], elements[2]))
						result.add(key);
				}
			}
			else {
				int num = elements.length / 3;
				values = getFieldList(record, elements[0]);
				//		 logger.warn("Raccolte multivalue " +   key  + " element " + elements[0]);

				if(values.isEmpty())
					continue;

				for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
					boolean ok = true;
					String valmarc = (String)iterator.next();
					//		 logger.warn("Raccolte valmarc " +   key  + " single value " + valmarc);
					for (int j =0; j<num ;j++) {
						if (!check_value_raccolte(valmarc,elements[3*j+1], elements[3*j+2])) {
							ok = false;
							break;
						}
						if (!ok) break;
					}
					if (ok) {
						//		 logger.warn("Raccolte insert " +   key  + " value " + valmarc);
						result.add(key);
						break;
					}
				}
			}
		}
		return result;
	}

	/*
	 * UTILITY
	 */
	@SuppressWarnings("unused")
	private String get_value_raccolte(String str, String tag) {
		// logger.warn("Raccolte val " +   str  + " tag " + tag);

		int begin = 0;
		int end = 0;
		if (tag.indexOf("[") > -1 ) {
			if (tag.indexOf("-") > -1 ) {
				begin = localParseInt(tag.substring(tag.indexOf('[')+1,tag.indexOf('-')), 0);
				end = localParseInt(tag.substring(tag.indexOf('-')+1,tag.indexOf(']')), 0);
			}
			else {
				begin = localParseInt(tag.substring(tag.indexOf('[')+1,tag.indexOf(']')), 0);
				end = begin +1;
			}
			// logger.warn("begin , end" + begin + "," + end);
			if (str != null && str.length() < end)
				return "";
			str = str.substring(begin, end);
		}
		// logger.warn("Raccolte val end" +   str  );

		return str;
	}
	private boolean check_value_raccolte(String str, String op, String values) {
		//			logger.warn("Raccolte check " +   str  + " op " + op + " values " + values);
		if (str== null || str.trim().replaceAll("|","").isEmpty() )
			return false;
		String[] elements = values.split(",");

		for (int i=0; i<elements.length; i++) {
			//			logger.warn("Raccolte check values " +   str  + " op " + op + " val" + elements[i]);
			if (op.equalsIgnoreCase("eq") && str.trim().equalsIgnoreCase(elements[i]))
				return true;
			else if (op.equalsIgnoreCase("eq"))
				continue;
			if (op.equalsIgnoreCase("ct") && str.toLowerCase().trim().indexOf(elements[i].replaceAll("_"," ").toLowerCase()) != -1)
			{	
				//			logger.warn("Raccolte check contains " +   str.toLowerCase().trim()  +  " val " + elements[i].replaceAll("_"," ").toLowerCase());
				return true;
			}
			else if (op.equalsIgnoreCase("ct"))
				continue;
			int esito = str.trim().compareTo(elements[i]);
			if ((op.equalsIgnoreCase("eq") || op.equalsIgnoreCase("ge")  || op.equalsIgnoreCase("le")) && esito == 0)
				return true;
			if ((op.equalsIgnoreCase("lt") || op.equalsIgnoreCase("le")) && esito < 0 )
				return true;
			if ((op.equalsIgnoreCase("gt")  || op.equalsIgnoreCase("ge")) && esito > 0 )
				return true;
		}
		return false;
	}
	private int localParseInt(String str, int defValue) {
		int value = defValue;
		try {
			value = Integer.parseInt(str);
		} catch (NumberFormatException nfe) {
		}
		return (value);
	}
	public static String cleanPretitolo(String value) {
		if (value != null && value.indexOf(START_PRETITOLO) != -1 && value.indexOf(END_PRETITOLO) != -1) {
			int beginIndex = value.indexOf(START_PRETITOLO);
			int endIndex = value.indexOf(END_PRETITOLO);
			StringBuilder buffer = new StringBuilder();
			buffer.append(value.substring(0, beginIndex));
			buffer.append(value.substring(endIndex+END_PRETITOLO.length()));
			return buffer.toString();
		}
		return value;
	}

	public Set<String> getFieldFold(final Record record, String tagStr) {
		Set<String> values = getFieldList(record, tagStr);
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = (String) iterator.next();
			if (value.length() > 0)
				result.add (String.valueOf(foldToASCII(value.toCharArray(), value.length())).trim());
		}
		return result;
	}

	public static Set<String> getOperaNum(Set<String> values) {
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = iterator.next();
			if (value != null && value.length() > 0 && value.trim().indexOf(" ") > 0)
				result.add(value.substring(0, value.trim().indexOf(" ")));		
		}
		return result;
	}

	public static Set<String> cleanPretitolo(Set<String> values, String fold) {
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = iterator.next();
			if (value != null && value.indexOf(START_PRETITOLO) != -1 && value.indexOf(END_PRETITOLO) != -1) {
				int beginIndex = value.indexOf(START_PRETITOLO);
				int endIndex = value.indexOf(END_PRETITOLO);
				StringBuilder buffer = new StringBuilder();
				buffer.append(value.substring(0, beginIndex));
				buffer.append(value.substring(endIndex+END_PRETITOLO.length()));
				value = buffer.toString();
			}
			if (fold != null && fold.equals("1"))
				value = String.valueOf(foldToASCII(value.toCharArray(), value.length())).trim();

			result.add(value);

		}
		return result;
	}
	public static Set<String> getFold(Set<String> values) {
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = iterator.next();
			value = value.replaceAll(START_PRETITOLO, "").replaceAll(END_PRETITOLO, "");
			value = String.valueOf(foldToASCII(value.toCharArray(), value.length())).trim();
			result.add(value);
		}
		return result;
	}
	public static Set<String> cleanLuogo(Set<String> values) {
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = ((String) iterator.next()).trim();
			String first = "";
			StringBuilder buffer = new StringBuilder();
			if (value.matches("^[ \\\\\\?\\!\\[\t\n\f\r]*[sS]*\\.([ \t\n\f\r]*)[lL]\\.[\t \\]\n\f\r\\?!\\\\]*[\t \n\f\r]*$"))
				result.add("[s.l.]");
			else {
				// remove [poi] all'inizio
				if (value.startsWith("[poi] "))
					value = value.substring("[poi] ".length());
				// [, \, <, ?, @, (, &, 'parentesi_graffa_aperta', 'centesimo (intendo la piccola c tagliata verticalmente)', 'grado';
				if (value.startsWith("?") || value.startsWith("!") || 
						value.startsWith("[") || value.startsWith("\\") ||
						value.startsWith("<") || value.startsWith("@") ||
						value.startsWith("(") || value.startsWith("&") ||
						value.startsWith("{") || value.startsWith("¬∞") || value.startsWith("√ß")) {
					first = value.substring(0,1);
					value = value.substring(1);
				}
				// ], !, >, ? (solo se √® simmetrico a '?' in posizione iniziale), ), @, &, 'parentesi_graffa_chiusa'.

				if ((value.endsWith("?") && first.equals("?")) || value.endsWith("!") || 
						value.endsWith("]") || value.endsWith(">") || value.endsWith("@") ||
						value.endsWith(")") || value.endsWith("&") ||
						value.endsWith("}")) {
					buffer.append(value.substring(0, value.length()-1));
					result.add(buffer.toString());
				} else {
					result.add(String.valueOf(foldToASCII(value.toCharArray(),value.length())).trim());
				}
			}
		}
		return result;
	}
	public static Set<String> cleanEditore(Set<String> values) {
		Set<String> result = new LinkedHashSet<String>();
		for (Iterator<String> iterator = values.iterator(); iterator.hasNext();) {
			String value = iterator.next().trim();
			if (value.matches("^[ \\\\\\?!\\[\\(\t\n\f\r]*[sS]*\\.([ \t\n\f\r]*)[nN]\\.[!\\?\t \\]\n\f\r\\)\\\\]*[\t \n\f\r]*$"))				
				result.add("[s.n.]");
			else {
				// remove [poi] all'inizio
				if (value.startsWith("[poi] "))
					value = value.substring("[poi] ".length());
				result.add(String.valueOf(foldToASCII(value.toCharArray(),value.length())).trim());
			}
		}
		return result;
	}

	public static boolean validDate (String date) {
		if (date.length() != 4  || date.equals("9999") || date.equals("0000"))
			return false;
		try {
		} catch (NumberFormatException nfe) { 
			return false;
		}
		return true;
	}

        public static String replaceDate (String date, char conv) {
		if (date != null && date.length() > 2) {
		int len = date.length() - 2;

		String newdate = date.substring(0,2);
		for (int i=len; i<date.length();i++) {
			if (date.charAt(i) == '.')
			   newdate = newdate + conv;
			else
				newdate = newdate +  date.charAt(i);
		}
		 return newdate;
	}
	else
		return date;
	}

	/**
	 * Converts characters above ASCII to their ASCII equivalents.  For example,
	 * accents are removed from accented characters.
	 * @param input The string to fold
	 * @param length The number of characters in the input string
	 */
	public static char[] foldToASCII(char[] input, int length) {

		char[] output = new char[512];
		// Worst-case length required:
		final int maxSizeNeeded = 4 * length;
		if (output.length < maxSizeNeeded) {
			output = new char[getNextSize(maxSizeNeeded)];
		}

		int outputPos = 0;

		for (int pos = 0 ; pos < length ; ++pos) {
			final char c = input[pos];

			// Quick test: if it's not in range then just keep current character
			if (c < '\u0080') {
				output[outputPos++] = c;
			} else {
				switch (c) {
				case '\u00C0': // √Ä  [LATIN CAPITAL LETTER A WITH GRAVE]
				case '\u00C1': // √Å  [LATIN CAPITAL LETTER A WITH ACUTE]
				case '\u00C2': // √Ç  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX]
				case '\u00C3': // √É  [LATIN CAPITAL LETTER A WITH TILDE]
				case '\u00C4': // √Ñ  [LATIN CAPITAL LETTER A WITH DIAERESIS]
				case '\u00C5': // √Ö  [LATIN CAPITAL LETTER A WITH RING ABOVE]
				case '\u0100': // ƒÄ  [LATIN CAPITAL LETTER A WITH MACRON]
				case '\u0102': // ƒÇ  [LATIN CAPITAL LETTER A WITH BREVE]
				case '\u0104': // ƒÑ  [LATIN CAPITAL LETTER A WITH OGONEK]
				case '\u018F': // ∆è  http://en.wikipedia.org/wiki/Schwa  [LATIN CAPITAL LETTER SCHWA]
				case '\u01CD': // «ç  [LATIN CAPITAL LETTER A WITH CARON]
				case '\u01DE': // «û  [LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON]
				case '\u01E0': // «†  [LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON]
				case '\u01FA': // «∫  [LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE]
				case '\u0200': // »Ä  [LATIN CAPITAL LETTER A WITH DOUBLE GRAVE]
				case '\u0202': // »Ç  [LATIN CAPITAL LETTER A WITH INVERTED BREVE]
				case '\u0226': // »¶  [LATIN CAPITAL LETTER A WITH DOT ABOVE]
				case '\u023A': // »∫  [LATIN CAPITAL LETTER A WITH STROKE]
				case '\u1D00': // ·¥Ä  [LATIN LETTER SMALL CAPITAL A]
				case '\u1E00': // ·∏Ä  [LATIN CAPITAL LETTER A WITH RING BELOW]
				case '\u1EA0': // ·∫†  [LATIN CAPITAL LETTER A WITH DOT BELOW]
				case '\u1EA2': // ·∫¢  [LATIN CAPITAL LETTER A WITH HOOK ABOVE]
				case '\u1EA4': // ·∫§  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE]
				case '\u1EA6': // ·∫¶  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE]
				case '\u1EA8': // ·∫®  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1EAA': // ·∫™  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE]
				case '\u1EAC': // ·∫¨  [LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW]
				case '\u1EAE': // ·∫Æ  [LATIN CAPITAL LETTER A WITH BREVE AND ACUTE]
				case '\u1EB0': // ·∫∞  [LATIN CAPITAL LETTER A WITH BREVE AND GRAVE]
				case '\u1EB2': // ·∫≤  [LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE]
				case '\u1EB4': // ·∫¥  [LATIN CAPITAL LETTER A WITH BREVE AND TILDE]
				case '\u1EB6': // ·∫∂  [LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW]
				case '\u24B6': // ‚í∂  [CIRCLED LATIN CAPITAL LETTER A]
				case '\uFF21': // Ôº°  [FULLWIDTH LATIN CAPITAL LETTER A]
					output[outputPos++] = 'A';
					break;
				case '\u00E0': // √†  [LATIN SMALL LETTER A WITH GRAVE]
				case '\u00E1': // √°  [LATIN SMALL LETTER A WITH ACUTE]
				case '\u00E2': // √¢  [LATIN SMALL LETTER A WITH CIRCUMFLEX]
				case '\u00E3': // √£  [LATIN SMALL LETTER A WITH TILDE]
				case '\u00E4': // √§  [LATIN SMALL LETTER A WITH DIAERESIS]
				case '\u00E5': // √•  [LATIN SMALL LETTER A WITH RING ABOVE]
				case '\u0101': // ƒÅ  [LATIN SMALL LETTER A WITH MACRON]
				case '\u0103': // ƒÉ  [LATIN SMALL LETTER A WITH BREVE]
				case '\u0105': // ƒÖ  [LATIN SMALL LETTER A WITH OGONEK]
				case '\u01CE': // «é  [LATIN SMALL LETTER A WITH CARON]
				case '\u01DF': // «ü  [LATIN SMALL LETTER A WITH DIAERESIS AND MACRON]
				case '\u01E1': // «°  [LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON]
				case '\u01FB': // «ª  [LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE]
				case '\u0201': // »Å  [LATIN SMALL LETTER A WITH DOUBLE GRAVE]
				case '\u0203': // »É  [LATIN SMALL LETTER A WITH INVERTED BREVE]
				case '\u0227': // »ß  [LATIN SMALL LETTER A WITH DOT ABOVE]
				case '\u0250': // …ê  [LATIN SMALL LETTER TURNED A]
				case '\u0259': // …ô  [LATIN SMALL LETTER SCHWA]
				case '\u025A': // …ö  [LATIN SMALL LETTER SCHWA WITH HOOK]
				case '\u1D8F': // ·∂è  [LATIN SMALL LETTER A WITH RETROFLEX HOOK]
				case '\u1D95': // ·∂ï  [LATIN SMALL LETTER SCHWA WITH RETROFLEX HOOK]
				case '\u1E01': // ·∫°  [LATIN SMALL LETTER A WITH RING BELOW]
				case '\u1E9A': // ·∫£  [LATIN SMALL LETTER A WITH RIGHT HALF RING]
				case '\u1EA1': // ·∫°  [LATIN SMALL LETTER A WITH DOT BELOW]
				case '\u1EA3': // ·∫£  [LATIN SMALL LETTER A WITH HOOK ABOVE]
				case '\u1EA5': // ·∫•  [LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE]
				case '\u1EA7': // ·∫ß  [LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE]
				case '\u1EA9': // ·∫©  [LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1EAB': // ·∫´  [LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE]
				case '\u1EAD': // ·∫≠  [LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW]
				case '\u1EAF': // ·∫Ø  [LATIN SMALL LETTER A WITH BREVE AND ACUTE]
				case '\u1EB1': // ·∫±  [LATIN SMALL LETTER A WITH BREVE AND GRAVE]
				case '\u1EB3': // ·∫≥  [LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE]
				case '\u1EB5': // ·∫µ  [LATIN SMALL LETTER A WITH BREVE AND TILDE]
				case '\u1EB7': // ·∫∑  [LATIN SMALL LETTER A WITH BREVE AND DOT BELOW]
				case '\u2090': // ‚Çê  [LATIN SUBSCRIPT SMALL LETTER A]
				case '\u2094': // ‚Çî  [LATIN SUBSCRIPT SMALL LETTER SCHWA]
				case '\u24D0': // ‚ìê  [CIRCLED LATIN SMALL LETTER A]
				case '\u2C65': // ‚±•  [LATIN SMALL LETTER A WITH STROKE]
				case '\u2C6F': // ‚±Ø  [LATIN CAPITAL LETTER TURNED A]
				case '\uFF41': // ÔΩÅ  [FULLWIDTH LATIN SMALL LETTER A]
					output[outputPos++] = 'a';
					break;
				case '\uA732': // Íú≤  [LATIN CAPITAL LETTER AA]
					output[outputPos++] = 'A';
					output[outputPos++] = 'A';
					break;
				case '\u00C6': // √Ü  [LATIN CAPITAL LETTER AE]
				case '\u01E2': // «¢  [LATIN CAPITAL LETTER AE WITH MACRON]
				case '\u01FC': // «º  [LATIN CAPITAL LETTER AE WITH ACUTE]
				case '\u1D01': // ·¥Å  [LATIN LETTER SMALL CAPITAL AE]
					output[outputPos++] = 'A';
					output[outputPos++] = 'E';
					break;
				case '\uA734': // Íú¥  [LATIN CAPITAL LETTER AO]
					output[outputPos++] = 'A';                    
					output[outputPos++] = 'O';
					break;
				case '\uA736': // Íú∂  [LATIN CAPITAL LETTER AU]
					output[outputPos++] = 'A';
					output[outputPos++] = 'U';
					break;
				case '\uA738': // Íú∏  [LATIN CAPITAL LETTER AV]
				case '\uA73A': // Íú∫  [LATIN CAPITAL LETTER AV WITH HORIZONTAL BAR]
					output[outputPos++] = 'A';
					output[outputPos++] = 'V';
					break;
				case '\uA73C': // Íúº  [LATIN CAPITAL LETTER AY]
					output[outputPos++] = 'A';
					output[outputPos++] = 'Y';
					break;
				case '\u249C': // ‚íú  [PARENTHESIZED LATIN SMALL LETTER A]
					output[outputPos++] = '(';
					output[outputPos++] = 'a';
					output[outputPos++] = ')';
					break;
				case '\uA733': // Íú≥  [LATIN SMALL LETTER AA]
					output[outputPos++] = 'a';
					output[outputPos++] = 'a';
					break;
				case '\u00E6': // √¶  [LATIN SMALL LETTER AE]
				case '\u01E3': // «£  [LATIN SMALL LETTER AE WITH MACRON]
				case '\u01FD': // «Ω  [LATIN SMALL LETTER AE WITH ACUTE]
				case '\u1D02': // ·¥Ç  [LATIN SMALL LETTER TURNED AE]
					output[outputPos++] = 'a';
					output[outputPos++] = 'e';
					break;
				case '\uA735': // Íúµ  [LATIN SMALL LETTER AO]
					output[outputPos++] = 'a';
					output[outputPos++] = 'o';
					break;
				case '\uA737': // Íú∑  [LATIN SMALL LETTER AU]
					output[outputPos++] = 'a';
					output[outputPos++] = 'u';
					break;
				case '\uA739': // Íúπ  [LATIN SMALL LETTER AV]
				case '\uA73B': // Íúª  [LATIN SMALL LETTER AV WITH HORIZONTAL BAR]
					output[outputPos++] = 'a';
					output[outputPos++] = 'v';
					break;
				case '\uA73D': // ÍúΩ  [LATIN SMALL LETTER AY]
					output[outputPos++] = 'a';
					output[outputPos++] = 'y';
					break;
				case '\u0181': // ∆Å  [LATIN CAPITAL LETTER B WITH HOOK]
				case '\u0182': // ∆Ç  [LATIN CAPITAL LETTER B WITH TOPBAR]
				case '\u0243': // …É  [LATIN CAPITAL LETTER B WITH STROKE]
				case '\u0299': //  ô  [LATIN LETTER SMALL CAPITAL B]
				case '\u1D03': // ·¥É  [LATIN LETTER SMALL CAPITAL BARRED B]
				case '\u1E02': // ·∏Ç  [LATIN CAPITAL LETTER B WITH DOT ABOVE]
				case '\u1E04': // ·∏Ñ  [LATIN CAPITAL LETTER B WITH DOT BELOW]
				case '\u1E06': // ·∏Ü  [LATIN CAPITAL LETTER B WITH LINE BELOW]
				case '\u24B7': // ‚í∑  [CIRCLED LATIN CAPITAL LETTER B]
				case '\uFF22': // Ôº¢  [FULLWIDTH LATIN CAPITAL LETTER B]
					output[outputPos++] = 'B';
					break;
				case '\u0180': // ∆Ä  [LATIN SMALL LETTER B WITH STROKE]
				case '\u0183': // ∆É  [LATIN SMALL LETTER B WITH TOPBAR]
				case '\u0253': // …ì  [LATIN SMALL LETTER B WITH HOOK]
				case '\u1D6C': // ·µ¨  [LATIN SMALL LETTER B WITH MIDDLE TILDE]
				case '\u1D80': // ·∂Ä  [LATIN SMALL LETTER B WITH PALATAL HOOK]
				case '\u1E03': // ·∏É  [LATIN SMALL LETTER B WITH DOT ABOVE]
				case '\u1E05': // ·∏Ö  [LATIN SMALL LETTER B WITH DOT BELOW]
				case '\u1E07': // ·∏á  [LATIN SMALL LETTER B WITH LINE BELOW]
				case '\u24D1': // ‚ìë  [CIRCLED LATIN SMALL LETTER B]
				case '\uFF42': // ÔΩÇ  [FULLWIDTH LATIN SMALL LETTER B]
					output[outputPos++] = 'b';
					break;
				case '\u249D': // ‚íù  [PARENTHESIZED LATIN SMALL LETTER B]
					output[outputPos++] = '(';                    
					output[outputPos++] = 'b';
					output[outputPos++] = ')';
					break;
				case '\u00C7': // √á  [LATIN CAPITAL LETTER C WITH CEDILLA]
				case '\u0106': // ƒÜ  [LATIN CAPITAL LETTER C WITH ACUTE]
				case '\u0108': // ƒà  [LATIN CAPITAL LETTER C WITH CIRCUMFLEX]
				case '\u010A': // ƒä  [LATIN CAPITAL LETTER C WITH DOT ABOVE]
				case '\u010C': // ƒå  [LATIN CAPITAL LETTER C WITH CARON]
				case '\u0187': // ∆á  [LATIN CAPITAL LETTER C WITH HOOK]
				case '\u023B': // »ª  [LATIN CAPITAL LETTER C WITH STROKE]
				case '\u0297': //  ó  [LATIN LETTER STRETCHED C]
				case '\u1D04': // ·¥Ñ  [LATIN LETTER SMALL CAPITAL C]
				case '\u1E08': // ·∏à  [LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE]
				case '\u24B8': // ‚í∏  [CIRCLED LATIN CAPITAL LETTER C]
				case '\uFF23': // Ôº£  [FULLWIDTH LATIN CAPITAL LETTER C]
					output[outputPos++] = 'C';
					break;
				case '\u00E7': // √ß  [LATIN SMALL LETTER C WITH CEDILLA]
				case '\u0107': // ƒá  [LATIN SMALL LETTER C WITH ACUTE]
				case '\u0109': // ƒâ  [LATIN SMALL LETTER C WITH CIRCUMFLEX]
				case '\u010B': // ƒã  [LATIN SMALL LETTER C WITH DOT ABOVE]
				case '\u010D': // ƒç  [LATIN SMALL LETTER C WITH CARON]
				case '\u0188': // ∆à  [LATIN SMALL LETTER C WITH HOOK]
				case '\u023C': // »º  [LATIN SMALL LETTER C WITH STROKE]
				case '\u0255': // …ï  [LATIN SMALL LETTER C WITH CURL]
				case '\u1E09': // ·∏â  [LATIN SMALL LETTER C WITH CEDILLA AND ACUTE]
				case '\u2184': // ‚ÜÑ  [LATIN SMALL LETTER REVERSED C]
				case '\u24D2': // ‚ìí  [CIRCLED LATIN SMALL LETTER C]
				case '\uA73E': // Íúæ  [LATIN CAPITAL LETTER REVERSED C WITH DOT]
				case '\uA73F': // Íúø  [LATIN SMALL LETTER REVERSED C WITH DOT]
				case '\uFF43': // ÔΩÉ  [FULLWIDTH LATIN SMALL LETTER C]
					output[outputPos++] = 'c';
					break;
				case '\u249E': // ‚íû  [PARENTHESIZED LATIN SMALL LETTER C]
					output[outputPos++] = '(';
					output[outputPos++] = 'c';
					output[outputPos++] = ')';
					break;
				case '\u00D0': // √ê  [LATIN CAPITAL LETTER ETH]
				case '\u010E': // ƒé  [LATIN CAPITAL LETTER D WITH CARON]
				case '\u0110': // ƒê  [LATIN CAPITAL LETTER D WITH STROKE]
				case '\u0189': // ∆â  [LATIN CAPITAL LETTER AFRICAN D]
				case '\u018A': // ∆ä  [LATIN CAPITAL LETTER D WITH HOOK]
				case '\u018B': // ∆ã  [LATIN CAPITAL LETTER D WITH TOPBAR]
				case '\u1D05': // ·¥Ö  [LATIN LETTER SMALL CAPITAL D]
				case '\u1D06': // ·¥Ü  [LATIN LETTER SMALL CAPITAL ETH]
				case '\u1E0A': // ·∏ä  [LATIN CAPITAL LETTER D WITH DOT ABOVE]
				case '\u1E0C': // ·∏å  [LATIN CAPITAL LETTER D WITH DOT BELOW]
				case '\u1E0E': // ·∏é  [LATIN CAPITAL LETTER D WITH LINE BELOW]
				case '\u1E10': // ·∏ê  [LATIN CAPITAL LETTER D WITH CEDILLA]
				case '\u1E12': // ·∏í  [LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW]
				case '\u24B9': // ‚íπ  [CIRCLED LATIN CAPITAL LETTER D]
				case '\uA779': // Íùπ  [LATIN CAPITAL LETTER INSULAR D]
				case '\uFF24': // Ôº§  [FULLWIDTH LATIN CAPITAL LETTER D]
					output[outputPos++] = 'D';
					break;
				case '\u00F0': // √∞  [LATIN SMALL LETTER ETH]
				case '\u010F': // ƒè  [LATIN SMALL LETTER D WITH CARON]
				case '\u0111': // ƒë  [LATIN SMALL LETTER D WITH STROKE]
				case '\u018C': // ∆å  [LATIN SMALL LETTER D WITH TOPBAR]
				case '\u0221': // »°  [LATIN SMALL LETTER D WITH CURL]
				case '\u0256': // …ñ  [LATIN SMALL LETTER D WITH TAIL]
				case '\u0257': // …ó  [LATIN SMALL LETTER D WITH HOOK]
				case '\u1D6D': // ·µ≠  [LATIN SMALL LETTER D WITH MIDDLE TILDE]
				case '\u1D81': // ·∂Å  [LATIN SMALL LETTER D WITH PALATAL HOOK]
				case '\u1D91': // ·∂ë  [LATIN SMALL LETTER D WITH HOOK AND TAIL]
				case '\u1E0B': // ·∏ã  [LATIN SMALL LETTER D WITH DOT ABOVE]
				case '\u1E0D': // ·∏ç  [LATIN SMALL LETTER D WITH DOT BELOW]
				case '\u1E0F': // ·∏è  [LATIN SMALL LETTER D WITH LINE BELOW]
				case '\u1E11': // ·∏ë  [LATIN SMALL LETTER D WITH CEDILLA]
				case '\u1E13': // ·∏ì  [LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW]
				case '\u24D3': // ‚ìì  [CIRCLED LATIN SMALL LETTER D]
				case '\uA77A': // Íù∫  [LATIN SMALL LETTER INSULAR D]
				case '\uFF44': // ÔΩÑ  [FULLWIDTH LATIN SMALL LETTER D]
					output[outputPos++] = 'd';
					break;
				case '\u01C4': // «Ñ  [LATIN CAPITAL LETTER DZ WITH CARON]
				case '\u01F1': // «±  [LATIN CAPITAL LETTER DZ]
					output[outputPos++] = 'D';
					output[outputPos++] = 'Z';
					break;
				case '\u01C5': // «Ö  [LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON]
				case '\u01F2': // «≤  [LATIN CAPITAL LETTER D WITH SMALL LETTER Z]
					output[outputPos++] = 'D';
					output[outputPos++] = 'z';
					break;
				case '\u249F': // ‚íü  [PARENTHESIZED LATIN SMALL LETTER D]
					output[outputPos++] = '(';
					output[outputPos++] = 'd';
					output[outputPos++] = ')';
					break;
				case '\u0238': // »∏  [LATIN SMALL LETTER DB DIGRAPH]
					output[outputPos++] = 'd';
					output[outputPos++] = 'b';
					break;
				case '\u01C6': // «Ü  [LATIN SMALL LETTER DZ WITH CARON]
				case '\u01F3': // «≥  [LATIN SMALL LETTER DZ]
				case '\u02A3': //  £  [LATIN SMALL LETTER DZ DIGRAPH]
				case '\u02A5': //  •  [LATIN SMALL LETTER DZ DIGRAPH WITH CURL]
					output[outputPos++] = 'd';
					output[outputPos++] = 'z';
					break;
				case '\u00C8': // √à  [LATIN CAPITAL LETTER E WITH GRAVE]
				case '\u00C9': // √â  [LATIN CAPITAL LETTER E WITH ACUTE]
				case '\u00CA': // √ä  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX]
				case '\u00CB': // √ã  [LATIN CAPITAL LETTER E WITH DIAERESIS]
				case '\u0112': // ƒí  [LATIN CAPITAL LETTER E WITH MACRON]
				case '\u0114': // ƒî  [LATIN CAPITAL LETTER E WITH BREVE]
				case '\u0116': // ƒñ  [LATIN CAPITAL LETTER E WITH DOT ABOVE]
				case '\u0118': // ƒò  [LATIN CAPITAL LETTER E WITH OGONEK]
				case '\u011A': // ƒö  [LATIN CAPITAL LETTER E WITH CARON]
				case '\u018E': // ∆é  [LATIN CAPITAL LETTER REVERSED E]
				case '\u0190': // ∆ê  [LATIN CAPITAL LETTER OPEN E]
				case '\u0204': // »Ñ  [LATIN CAPITAL LETTER E WITH DOUBLE GRAVE]
				case '\u0206': // »Ü  [LATIN CAPITAL LETTER E WITH INVERTED BREVE]
				case '\u0228': // »®  [LATIN CAPITAL LETTER E WITH CEDILLA]
				case '\u0246': // …Ü  [LATIN CAPITAL LETTER E WITH STROKE]
				case '\u1D07': // ·¥á  [LATIN LETTER SMALL CAPITAL E]
				case '\u1E14': // ·∏î  [LATIN CAPITAL LETTER E WITH MACRON AND GRAVE]
				case '\u1E16': // ·∏ñ  [LATIN CAPITAL LETTER E WITH MACRON AND ACUTE]
				case '\u1E18': // ·∏ò  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW]
				case '\u1E1A': // ·∏ö  [LATIN CAPITAL LETTER E WITH TILDE BELOW]
				case '\u1E1C': // ·∏ú  [LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE]
				case '\u1EB8': // ·∫∏  [LATIN CAPITAL LETTER E WITH DOT BELOW]
				case '\u1EBA': // ·∫∫  [LATIN CAPITAL LETTER E WITH HOOK ABOVE]
				case '\u1EBC': // ·∫º  [LATIN CAPITAL LETTER E WITH TILDE]
				case '\u1EBE': // ·∫æ  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE]
				case '\u1EC0': // ·ªÄ  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE]
				case '\u1EC2': // ·ªÇ  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1EC4': // ·ªÑ  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE]
				case '\u1EC6': // ·ªÜ  [LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW]
				case '\u24BA': // ‚í∫  [CIRCLED LATIN CAPITAL LETTER E]
				case '\u2C7B': // ‚±ª  [LATIN LETTER SMALL CAPITAL TURNED E]
				case '\uFF25': // Ôº•  [FULLWIDTH LATIN CAPITAL LETTER E]
					output[outputPos++] = 'E';
					break;
				case '\u00E8': // √®  [LATIN SMALL LETTER E WITH GRAVE]
				case '\u00E9': // √©  [LATIN SMALL LETTER E WITH ACUTE]
				case '\u00EA': // √™  [LATIN SMALL LETTER E WITH CIRCUMFLEX]
				case '\u00EB': // √´  [LATIN SMALL LETTER E WITH DIAERESIS]
				case '\u0113': // ƒì  [LATIN SMALL LETTER E WITH MACRON]
				case '\u0115': // ƒï  [LATIN SMALL LETTER E WITH BREVE]
				case '\u0117': // ƒó  [LATIN SMALL LETTER E WITH DOT ABOVE]
				case '\u0119': // ƒô  [LATIN SMALL LETTER E WITH OGONEK]
				case '\u011B': // ƒõ  [LATIN SMALL LETTER E WITH CARON]
				case '\u01DD': // «ù  [LATIN SMALL LETTER TURNED E]
				case '\u0205': // »Ö  [LATIN SMALL LETTER E WITH DOUBLE GRAVE]
				case '\u0207': // »á  [LATIN SMALL LETTER E WITH INVERTED BREVE]
				case '\u0229': // »©  [LATIN SMALL LETTER E WITH CEDILLA]
				case '\u0247': // …á  [LATIN SMALL LETTER E WITH STROKE]
				case '\u0258': // …ò  [LATIN SMALL LETTER REVERSED E]
				case '\u025B': // …õ  [LATIN SMALL LETTER OPEN E]
				case '\u025C': // …ú  [LATIN SMALL LETTER REVERSED OPEN E]
				case '\u025D': // …ù  [LATIN SMALL LETTER REVERSED OPEN E WITH HOOK]
				case '\u025E': // …û  [LATIN SMALL LETTER CLOSED REVERSED OPEN E]
				case '\u029A': //  ö  [LATIN SMALL LETTER CLOSED OPEN E]
				case '\u1D08': // ·¥à  [LATIN SMALL LETTER TURNED OPEN E]
				case '\u1D92': // ·∂í  [LATIN SMALL LETTER E WITH RETROFLEX HOOK]
				case '\u1D93': // ·∂ì  [LATIN SMALL LETTER OPEN E WITH RETROFLEX HOOK]
				case '\u1D94': // ·∂î  [LATIN SMALL LETTER REVERSED OPEN E WITH RETROFLEX HOOK]
				case '\u1E15': // ·∏ï  [LATIN SMALL LETTER E WITH MACRON AND GRAVE]
				case '\u1E17': // ·∏ó  [LATIN SMALL LETTER E WITH MACRON AND ACUTE]
				case '\u1E19': // ·∏ô  [LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW]
				case '\u1E1B': // ·∏õ  [LATIN SMALL LETTER E WITH TILDE BELOW]
				case '\u1E1D': // ·∏ù  [LATIN SMALL LETTER E WITH CEDILLA AND BREVE]
				case '\u1EB9': // ·∫π  [LATIN SMALL LETTER E WITH DOT BELOW]
				case '\u1EBB': // ·∫ª  [LATIN SMALL LETTER E WITH HOOK ABOVE]
				case '\u1EBD': // ·∫Ω  [LATIN SMALL LETTER E WITH TILDE]
				case '\u1EBF': // ·∫ø  [LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE]
				case '\u1EC1': // ·ªÅ  [LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE]
				case '\u1EC3': // ·ªÉ  [LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1EC5': // ·ªÖ  [LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE]
				case '\u1EC7': // ·ªá  [LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW]
				case '\u2091': // ‚Çë  [LATIN SUBSCRIPT SMALL LETTER E]
				case '\u24D4': // ‚ìî  [CIRCLED LATIN SMALL LETTER E]
				case '\u2C78': // ‚±∏  [LATIN SMALL LETTER E WITH NOTCH]
				case '\uFF45': // ÔΩÖ  [FULLWIDTH LATIN SMALL LETTER E]
					output[outputPos++] = 'e';
					break;
				case '\u24A0': // ‚í†  [PARENTHESIZED LATIN SMALL LETTER E]
					output[outputPos++] = '(';
					output[outputPos++] = 'e';
					output[outputPos++] = ')';
					break;
				case '\u0191': // ∆ë  [LATIN CAPITAL LETTER F WITH HOOK]
				case '\u1E1E': // ·∏û  [LATIN CAPITAL LETTER F WITH DOT ABOVE]
				case '\u24BB': // ‚íª  [CIRCLED LATIN CAPITAL LETTER F]
				case '\uA730': // Íú∞  [LATIN LETTER SMALL CAPITAL F]
				case '\uA77B': // Íùª  [LATIN CAPITAL LETTER INSULAR F]
				case '\uA7FB': // Íüª  [LATIN EPIGRAPHIC LETTER REVERSED F]
				case '\uFF26': // Ôº¶  [FULLWIDTH LATIN CAPITAL LETTER F]
					output[outputPos++] = 'F';
					break;
				case '\u0192': // ∆í  [LATIN SMALL LETTER F WITH HOOK]
				case '\u1D6E': // ·µÆ  [LATIN SMALL LETTER F WITH MIDDLE TILDE]
				case '\u1D82': // ·∂Ç  [LATIN SMALL LETTER F WITH PALATAL HOOK]
				case '\u1E1F': // ·∏ü  [LATIN SMALL LETTER F WITH DOT ABOVE]
				case '\u1E9B': // ·∫õ  [LATIN SMALL LETTER LONG S WITH DOT ABOVE]
				case '\u24D5': // ‚ìï  [CIRCLED LATIN SMALL LETTER F]
				case '\uA77C': // Íùº  [LATIN SMALL LETTER INSULAR F]
				case '\uFF46': // ÔΩÜ  [FULLWIDTH LATIN SMALL LETTER F]
					output[outputPos++] = 'f';
					break;
				case '\u24A1': // ‚í°  [PARENTHESIZED LATIN SMALL LETTER F]
					output[outputPos++] = '(';
					output[outputPos++] = 'f';
					output[outputPos++] = ')';
					break;
				case '\uFB00': // Ô¨Ä  [LATIN SMALL LIGATURE FF]
					output[outputPos++] = 'f';
					output[outputPos++] = 'f';
					break;
				case '\uFB03': // Ô¨É  [LATIN SMALL LIGATURE FFI]
					output[outputPos++] = 'f';
					output[outputPos++] = 'f';
					output[outputPos++] = 'i';
					break;
				case '\uFB04': // Ô¨Ñ  [LATIN SMALL LIGATURE FFL]
					output[outputPos++] = 'f';
					output[outputPos++] = 'f';
					output[outputPos++] = 'l';
					break;
				case '\uFB01': // Ô¨Å  [LATIN SMALL LIGATURE FI]
					output[outputPos++] = 'f';
					output[outputPos++] = 'i';
					break;
				case '\uFB02': // Ô¨Ç  [LATIN SMALL LIGATURE FL]
					output[outputPos++] = 'f';
					output[outputPos++] = 'l';
					break;
				case '\u011C': // ƒú  [LATIN CAPITAL LETTER G WITH CIRCUMFLEX]
				case '\u011E': // ƒû  [LATIN CAPITAL LETTER G WITH BREVE]
				case '\u0120': // ƒ†  [LATIN CAPITAL LETTER G WITH DOT ABOVE]
				case '\u0122': // ƒ¢  [LATIN CAPITAL LETTER G WITH CEDILLA]
				case '\u0193': // ∆ì  [LATIN CAPITAL LETTER G WITH HOOK]
				case '\u01E4': // «§  [LATIN CAPITAL LETTER G WITH STROKE]
				case '\u01E5': // «•  [LATIN SMALL LETTER G WITH STROKE]
				case '\u01E6': // «¶  [LATIN CAPITAL LETTER G WITH CARON]
				case '\u01E7': // «ß  [LATIN SMALL LETTER G WITH CARON]
				case '\u01F4': // «¥  [LATIN CAPITAL LETTER G WITH ACUTE]
				case '\u0262': // …¢  [LATIN LETTER SMALL CAPITAL G]
				case '\u029B': //  õ  [LATIN LETTER SMALL CAPITAL G WITH HOOK]
				case '\u1E20': // ·∏†  [LATIN CAPITAL LETTER G WITH MACRON]
				case '\u24BC': // ‚íº  [CIRCLED LATIN CAPITAL LETTER G]
				case '\uA77D': // ÍùΩ  [LATIN CAPITAL LETTER INSULAR G]
				case '\uA77E': // Íùæ  [LATIN CAPITAL LETTER TURNED INSULAR G]
				case '\uFF27': // Ôºß  [FULLWIDTH LATIN CAPITAL LETTER G]
					output[outputPos++] = 'G';
					break;
				case '\u011D': // ƒù  [LATIN SMALL LETTER G WITH CIRCUMFLEX]
				case '\u011F': // ƒü  [LATIN SMALL LETTER G WITH BREVE]
				case '\u0121': // ƒ°  [LATIN SMALL LETTER G WITH DOT ABOVE]
				case '\u0123': // ƒ£  [LATIN SMALL LETTER G WITH CEDILLA]
				case '\u01F5': // «µ  [LATIN SMALL LETTER G WITH ACUTE]
				case '\u0260': // …†  [LATIN SMALL LETTER G WITH HOOK]
				case '\u0261': // …°  [LATIN SMALL LETTER SCRIPT G]
				case '\u1D77': // ·µ∑  [LATIN SMALL LETTER TURNED G]
				case '\u1D79': // ·µπ  [LATIN SMALL LETTER INSULAR G]
				case '\u1D83': // ·∂É  [LATIN SMALL LETTER G WITH PALATAL HOOK]
				case '\u1E21': // ·∏°  [LATIN SMALL LETTER G WITH MACRON]
				case '\u24D6': // ‚ìñ  [CIRCLED LATIN SMALL LETTER G]
				case '\uA77F': // Íùø  [LATIN SMALL LETTER TURNED INSULAR G]
				case '\uFF47': // ÔΩá  [FULLWIDTH LATIN SMALL LETTER G]
					output[outputPos++] = 'g';
					break;
				case '\u24A2': // ‚í¢  [PARENTHESIZED LATIN SMALL LETTER G]
					output[outputPos++] = '(';
					output[outputPos++] = 'g';
					output[outputPos++] = ')';
					break;
				case '\u0124': // ƒ§  [LATIN CAPITAL LETTER H WITH CIRCUMFLEX]
				case '\u0126': // ƒ¶  [LATIN CAPITAL LETTER H WITH STROKE]
				case '\u021E': // »û  [LATIN CAPITAL LETTER H WITH CARON]
				case '\u029C': //  ú  [LATIN LETTER SMALL CAPITAL H]
				case '\u1E22': // ·∏¢  [LATIN CAPITAL LETTER H WITH DOT ABOVE]
				case '\u1E24': // ·∏§  [LATIN CAPITAL LETTER H WITH DOT BELOW]
				case '\u1E26': // ·∏¶  [LATIN CAPITAL LETTER H WITH DIAERESIS]
				case '\u1E28': // ·∏®  [LATIN CAPITAL LETTER H WITH CEDILLA]
				case '\u1E2A': // ·∏™  [LATIN CAPITAL LETTER H WITH BREVE BELOW]
				case '\u24BD': // ‚íΩ  [CIRCLED LATIN CAPITAL LETTER H]
				case '\u2C67': // ‚±ß  [LATIN CAPITAL LETTER H WITH DESCENDER]
				case '\u2C75': // ‚±µ  [LATIN CAPITAL LETTER HALF H]
				case '\uFF28': // Ôº®  [FULLWIDTH LATIN CAPITAL LETTER H]
					output[outputPos++] = 'H';
					break;
				case '\u0125': // ƒ•  [LATIN SMALL LETTER H WITH CIRCUMFLEX]
				case '\u0127': // ƒß  [LATIN SMALL LETTER H WITH STROKE]
				case '\u021F': // »ü  [LATIN SMALL LETTER H WITH CARON]
				case '\u0265': // …•  [LATIN SMALL LETTER TURNED H]
				case '\u0266': // …¶  [LATIN SMALL LETTER H WITH HOOK]
				case '\u02AE': //  Æ  [LATIN SMALL LETTER TURNED H WITH FISHHOOK]
				case '\u02AF': //  Ø  [LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL]
				case '\u1E23': // ·∏£  [LATIN SMALL LETTER H WITH DOT ABOVE]
				case '\u1E25': // ·∏•  [LATIN SMALL LETTER H WITH DOT BELOW]
				case '\u1E27': // ·∏ß  [LATIN SMALL LETTER H WITH DIAERESIS]
				case '\u1E29': // ·∏©  [LATIN SMALL LETTER H WITH CEDILLA]
				case '\u1E2B': // ·∏´  [LATIN SMALL LETTER H WITH BREVE BELOW]
				case '\u1E96': // ·∫ñ  [LATIN SMALL LETTER H WITH LINE BELOW]
				case '\u24D7': // ‚ìó  [CIRCLED LATIN SMALL LETTER H]
				case '\u2C68': // ‚±®  [LATIN SMALL LETTER H WITH DESCENDER]
				case '\u2C76': // ‚±∂  [LATIN SMALL LETTER HALF H]
				case '\uFF48': // ÔΩà  [FULLWIDTH LATIN SMALL LETTER H]
					output[outputPos++] = 'h';
					break;
				case '\u01F6': // «∂  http://en.wikipedia.org/wiki/Hwair  [LATIN CAPITAL LETTER HWAIR]
					output[outputPos++] = 'H';
					output[outputPos++] = 'V';
					break;
				case '\u24A3': // ‚í£  [PARENTHESIZED LATIN SMALL LETTER H]
					output[outputPos++] = '(';
					output[outputPos++] = 'h';
					output[outputPos++] = ')';
					break;
				case '\u0195': // ∆ï  [LATIN SMALL LETTER HV]
					output[outputPos++] = 'h';
					output[outputPos++] = 'v';
					break;
				case '\u00CC': // √å  [LATIN CAPITAL LETTER I WITH GRAVE]
				case '\u00CD': // √ç  [LATIN CAPITAL LETTER I WITH ACUTE]
				case '\u00CE': // √é  [LATIN CAPITAL LETTER I WITH CIRCUMFLEX]
				case '\u00CF': // √è  [LATIN CAPITAL LETTER I WITH DIAERESIS]
				case '\u0128': // ƒ®  [LATIN CAPITAL LETTER I WITH TILDE]
				case '\u012A': // ƒ™  [LATIN CAPITAL LETTER I WITH MACRON]
				case '\u012C': // ƒ¨  [LATIN CAPITAL LETTER I WITH BREVE]
				case '\u012E': // ƒÆ  [LATIN CAPITAL LETTER I WITH OGONEK]
				case '\u0130': // ƒ∞  [LATIN CAPITAL LETTER I WITH DOT ABOVE]
				case '\u0196': // ∆ñ  [LATIN CAPITAL LETTER IOTA]
				case '\u0197': // ∆ó  [LATIN CAPITAL LETTER I WITH STROKE]
				case '\u01CF': // «è  [LATIN CAPITAL LETTER I WITH CARON]
				case '\u0208': // »à  [LATIN CAPITAL LETTER I WITH DOUBLE GRAVE]
				case '\u020A': // »ä  [LATIN CAPITAL LETTER I WITH INVERTED BREVE]
				case '\u026A': // …™  [LATIN LETTER SMALL CAPITAL I]
				case '\u1D7B': // ·µª  [LATIN SMALL CAPITAL LETTER I WITH STROKE]
				case '\u1E2C': // ·∏¨  [LATIN CAPITAL LETTER I WITH TILDE BELOW]
				case '\u1E2E': // ·∏Æ  [LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE]
				case '\u1EC8': // ·ªà  [LATIN CAPITAL LETTER I WITH HOOK ABOVE]
				case '\u1ECA': // ·ªä  [LATIN CAPITAL LETTER I WITH DOT BELOW]
				case '\u24BE': // ‚íæ  [CIRCLED LATIN CAPITAL LETTER I]
				case '\uA7FE': // Íüæ  [LATIN EPIGRAPHIC LETTER I LONGA]
				case '\uFF29': // Ôº©  [FULLWIDTH LATIN CAPITAL LETTER I]
					output[outputPos++] = 'I';
					break;
				case '\u00EC': // √¨  [LATIN SMALL LETTER I WITH GRAVE]
				case '\u00ED': // √≠  [LATIN SMALL LETTER I WITH ACUTE]
				case '\u00EE': // √Æ  [LATIN SMALL LETTER I WITH CIRCUMFLEX]
				case '\u00EF': // √Ø  [LATIN SMALL LETTER I WITH DIAERESIS]
				case '\u0129': // ƒ©  [LATIN SMALL LETTER I WITH TILDE]
				case '\u012B': // ƒ´  [LATIN SMALL LETTER I WITH MACRON]
				case '\u012D': // ƒ≠  [LATIN SMALL LETTER I WITH BREVE]
				case '\u012F': // ƒØ  [LATIN SMALL LETTER I WITH OGONEK]
				case '\u0131': // ƒ±  [LATIN SMALL LETTER DOTLESS I]
				case '\u01D0': // «ê  [LATIN SMALL LETTER I WITH CARON]
				case '\u0209': // »â  [LATIN SMALL LETTER I WITH DOUBLE GRAVE]
				case '\u020B': // »ã  [LATIN SMALL LETTER I WITH INVERTED BREVE]
				case '\u0268': // …®  [LATIN SMALL LETTER I WITH STROKE]
				case '\u1D09': // ·¥â  [LATIN SMALL LETTER TURNED I]
				case '\u1D62': // ·µ¢  [LATIN SUBSCRIPT SMALL LETTER I]
				case '\u1D7C': // ·µº  [LATIN SMALL LETTER IOTA WITH STROKE]
				case '\u1D96': // ·∂ñ  [LATIN SMALL LETTER I WITH RETROFLEX HOOK]
				case '\u1E2D': // ·∏≠  [LATIN SMALL LETTER I WITH TILDE BELOW]
				case '\u1E2F': // ·∏Ø  [LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE]
				case '\u1EC9': // ·ªâ  [LATIN SMALL LETTER I WITH HOOK ABOVE]
				case '\u1ECB': // ·ªã  [LATIN SMALL LETTER I WITH DOT BELOW]
				case '\u2071': // ‚Å±  [SUPERSCRIPT LATIN SMALL LETTER I]
				case '\u24D8': // ‚ìò  [CIRCLED LATIN SMALL LETTER I]
				case '\uFF49': // ÔΩâ  [FULLWIDTH LATIN SMALL LETTER I]
					output[outputPos++] = 'i';
					break;
				case '\u0132': // ƒ≤  [LATIN CAPITAL LIGATURE IJ]
					output[outputPos++] = 'I';
					output[outputPos++] = 'J';
					break;
				case '\u24A4': // ‚í§  [PARENTHESIZED LATIN SMALL LETTER I]
					output[outputPos++] = '(';
					output[outputPos++] = 'i';
					output[outputPos++] = ')';
					break;
				case '\u0133': // ƒ≥  [LATIN SMALL LIGATURE IJ]
					output[outputPos++] = 'i';
					output[outputPos++] = 'j';
					break;
				case '\u0134': // ƒ¥  [LATIN CAPITAL LETTER J WITH CIRCUMFLEX]
				case '\u0248': // …à  [LATIN CAPITAL LETTER J WITH STROKE]
				case '\u1D0A': // ·¥ä  [LATIN LETTER SMALL CAPITAL J]
				case '\u24BF': // ‚íø  [CIRCLED LATIN CAPITAL LETTER J]
				case '\uFF2A': // Ôº™  [FULLWIDTH LATIN CAPITAL LETTER J]
					output[outputPos++] = 'J';
					break;
				case '\u0135': // ƒµ  [LATIN SMALL LETTER J WITH CIRCUMFLEX]
				case '\u01F0': // «∞  [LATIN SMALL LETTER J WITH CARON]
				case '\u0237': // »∑  [LATIN SMALL LETTER DOTLESS J]
				case '\u0249': // …â  [LATIN SMALL LETTER J WITH STROKE]
				case '\u025F': // …ü  [LATIN SMALL LETTER DOTLESS J WITH STROKE]
				case '\u0284': //  Ñ  [LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK]
				case '\u029D': //  ù  [LATIN SMALL LETTER J WITH CROSSED-TAIL]
				case '\u24D9': // ‚ìô  [CIRCLED LATIN SMALL LETTER J]
				case '\u2C7C': // ‚±º  [LATIN SUBSCRIPT SMALL LETTER J]
				case '\uFF4A': // ÔΩä  [FULLWIDTH LATIN SMALL LETTER J]
					output[outputPos++] = 'j';
					break;
				case '\u24A5': // ‚í•  [PARENTHESIZED LATIN SMALL LETTER J]
					output[outputPos++] = '(';
					output[outputPos++] = 'j';
					output[outputPos++] = ')';
					break;
				case '\u0136': // ƒ∂  [LATIN CAPITAL LETTER K WITH CEDILLA]
				case '\u0198': // ∆ò  [LATIN CAPITAL LETTER K WITH HOOK]
				case '\u01E8': // «®  [LATIN CAPITAL LETTER K WITH CARON]
				case '\u1D0B': // ·¥ã  [LATIN LETTER SMALL CAPITAL K]
				case '\u1E30': // ·∏∞  [LATIN CAPITAL LETTER K WITH ACUTE]
				case '\u1E32': // ·∏≤  [LATIN CAPITAL LETTER K WITH DOT BELOW]
				case '\u1E34': // ·∏¥  [LATIN CAPITAL LETTER K WITH LINE BELOW]
				case '\u24C0': // ‚ìÄ  [CIRCLED LATIN CAPITAL LETTER K]
				case '\u2C69': // ‚±©  [LATIN CAPITAL LETTER K WITH DESCENDER]
				case '\uA740': // ÍùÄ  [LATIN CAPITAL LETTER K WITH STROKE]
				case '\uA742': // ÍùÇ  [LATIN CAPITAL LETTER K WITH DIAGONAL STROKE]
				case '\uA744': // ÍùÑ  [LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE]
				case '\uFF2B': // Ôº´  [FULLWIDTH LATIN CAPITAL LETTER K]
					output[outputPos++] = 'K';
					break;
				case '\u0137': // ƒ∑  [LATIN SMALL LETTER K WITH CEDILLA]
				case '\u0199': // ∆ô  [LATIN SMALL LETTER K WITH HOOK]
				case '\u01E9': // «©  [LATIN SMALL LETTER K WITH CARON]
				case '\u029E': //  û  [LATIN SMALL LETTER TURNED K]
				case '\u1D84': // ·∂Ñ  [LATIN SMALL LETTER K WITH PALATAL HOOK]
				case '\u1E31': // ·∏±  [LATIN SMALL LETTER K WITH ACUTE]
				case '\u1E33': // ·∏≥  [LATIN SMALL LETTER K WITH DOT BELOW]
				case '\u1E35': // ·∏µ  [LATIN SMALL LETTER K WITH LINE BELOW]
				case '\u24DA': // ‚ìö  [CIRCLED LATIN SMALL LETTER K]
				case '\u2C6A': // ‚±™  [LATIN SMALL LETTER K WITH DESCENDER]
				case '\uA741': // ÍùÅ  [LATIN SMALL LETTER K WITH STROKE]
				case '\uA743': // ÍùÉ  [LATIN SMALL LETTER K WITH DIAGONAL STROKE]
				case '\uA745': // ÍùÖ  [LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE]
				case '\uFF4B': // ÔΩã  [FULLWIDTH LATIN SMALL LETTER K]
					output[outputPos++] = 'k';
					break;
				case '\u24A6': // ‚í¶  [PARENTHESIZED LATIN SMALL LETTER K]
					output[outputPos++] = '(';
					output[outputPos++] = 'k';
					output[outputPos++] = ')';
					break;
				case '\u0139': // ƒπ  [LATIN CAPITAL LETTER L WITH ACUTE]
				case '\u013B': // ƒª  [LATIN CAPITAL LETTER L WITH CEDILLA]
				case '\u013D': // ƒΩ  [LATIN CAPITAL LETTER L WITH CARON]
				case '\u013F': // ƒø  [LATIN CAPITAL LETTER L WITH MIDDLE DOT]
				case '\u0141': // ≈Å  [LATIN CAPITAL LETTER L WITH STROKE]
				case '\u023D': // »Ω  [LATIN CAPITAL LETTER L WITH BAR]
				case '\u029F': //  ü  [LATIN LETTER SMALL CAPITAL L]
				case '\u1D0C': // ·¥å  [LATIN LETTER SMALL CAPITAL L WITH STROKE]
				case '\u1E36': // ·∏∂  [LATIN CAPITAL LETTER L WITH DOT BELOW]
				case '\u1E38': // ·∏∏  [LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON]
				case '\u1E3A': // ·∏∫  [LATIN CAPITAL LETTER L WITH LINE BELOW]
				case '\u1E3C': // ·∏º  [LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW]
				case '\u24C1': // ‚ìÅ  [CIRCLED LATIN CAPITAL LETTER L]
				case '\u2C60': // ‚±†  [LATIN CAPITAL LETTER L WITH DOUBLE BAR]
				case '\u2C62': // ‚±¢  [LATIN CAPITAL LETTER L WITH MIDDLE TILDE]
				case '\uA746': // ÍùÜ  [LATIN CAPITAL LETTER BROKEN L]
				case '\uA748': // Íùà  [LATIN CAPITAL LETTER L WITH HIGH STROKE]
				case '\uA780': // ÍûÄ  [LATIN CAPITAL LETTER TURNED L]
				case '\uFF2C': // Ôº¨  [FULLWIDTH LATIN CAPITAL LETTER L]
					output[outputPos++] = 'L';
					break;
				case '\u013A': // ƒ∫  [LATIN SMALL LETTER L WITH ACUTE]
				case '\u013C': // ƒº  [LATIN SMALL LETTER L WITH CEDILLA]
				case '\u013E': // ƒæ  [LATIN SMALL LETTER L WITH CARON]
				case '\u0140': // ≈Ä  [LATIN SMALL LETTER L WITH MIDDLE DOT]
				case '\u0142': // ≈Ç  [LATIN SMALL LETTER L WITH STROKE]
				case '\u019A': // ∆ö  [LATIN SMALL LETTER L WITH BAR]
				case '\u0234': // »¥  [LATIN SMALL LETTER L WITH CURL]
				case '\u026B': // …´  [LATIN SMALL LETTER L WITH MIDDLE TILDE]
				case '\u026C': // …¨  [LATIN SMALL LETTER L WITH BELT]
				case '\u026D': // …≠  [LATIN SMALL LETTER L WITH RETROFLEX HOOK]
				case '\u1D85': // ·∂Ö  [LATIN SMALL LETTER L WITH PALATAL HOOK]
				case '\u1E37': // ·∏∑  [LATIN SMALL LETTER L WITH DOT BELOW]
				case '\u1E39': // ·∏π  [LATIN SMALL LETTER L WITH DOT BELOW AND MACRON]
				case '\u1E3B': // ·∏ª  [LATIN SMALL LETTER L WITH LINE BELOW]
				case '\u1E3D': // ·∏Ω  [LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW]
				case '\u24DB': // ‚ìõ  [CIRCLED LATIN SMALL LETTER L]
				case '\u2C61': // ‚±°  [LATIN SMALL LETTER L WITH DOUBLE BAR]
				case '\uA747': // Íùá  [LATIN SMALL LETTER BROKEN L]
				case '\uA749': // Íùâ  [LATIN SMALL LETTER L WITH HIGH STROKE]
				case '\uA781': // ÍûÅ  [LATIN SMALL LETTER TURNED L]
				case '\uFF4C': // ÔΩå  [FULLWIDTH LATIN SMALL LETTER L]
					output[outputPos++] = 'l';
					break;
				case '\u01C7': // «á  [LATIN CAPITAL LETTER LJ]
					output[outputPos++] = 'L';
					output[outputPos++] = 'J';
					break;
				case '\u1EFA': // ·ª∫  [LATIN CAPITAL LETTER MIDDLE-WELSH LL]
					output[outputPos++] = 'L';
					output[outputPos++] = 'L';
					break;
				case '\u01C8': // «à  [LATIN CAPITAL LETTER L WITH SMALL LETTER J]
					output[outputPos++] = 'L';
					output[outputPos++] = 'j';
					break;
				case '\u24A7': // ‚íß  [PARENTHESIZED LATIN SMALL LETTER L]
					output[outputPos++] = '(';
					output[outputPos++] = 'l';
					output[outputPos++] = ')';
					break;
				case '\u01C9': // «â  [LATIN SMALL LETTER LJ]
					output[outputPos++] = 'l';
					output[outputPos++] = 'j';
					break;
				case '\u1EFB': // ·ªª  [LATIN SMALL LETTER MIDDLE-WELSH LL]
					output[outputPos++] = 'l';
					output[outputPos++] = 'l';
					break;
				case '\u02AA': //  ™  [LATIN SMALL LETTER LS DIGRAPH]
					output[outputPos++] = 'l';
					output[outputPos++] = 's';
					break;
				case '\u02AB': //  ´  [LATIN SMALL LETTER LZ DIGRAPH]
					output[outputPos++] = 'l';
					output[outputPos++] = 'z';
					break;
				case '\u019C': // ∆ú  [LATIN CAPITAL LETTER TURNED M]
				case '\u1D0D': // ·¥ç  [LATIN LETTER SMALL CAPITAL M]
				case '\u1E3E': // ·∏æ  [LATIN CAPITAL LETTER M WITH ACUTE]
				case '\u1E40': // ·πÄ  [LATIN CAPITAL LETTER M WITH DOT ABOVE]
				case '\u1E42': // ·πÇ  [LATIN CAPITAL LETTER M WITH DOT BELOW]
				case '\u24C2': // ‚ìÇ  [CIRCLED LATIN CAPITAL LETTER M]
				case '\u2C6E': // ‚±Æ  [LATIN CAPITAL LETTER M WITH HOOK]
				case '\uA7FD': // ÍüΩ  [LATIN EPIGRAPHIC LETTER INVERTED M]
				case '\uA7FF': // Íüø  [LATIN EPIGRAPHIC LETTER ARCHAIC M]
				case '\uFF2D': // Ôº≠  [FULLWIDTH LATIN CAPITAL LETTER M]
					output[outputPos++] = 'M';
					break;
				case '\u026F': // …Ø  [LATIN SMALL LETTER TURNED M]
				case '\u0270': // …∞  [LATIN SMALL LETTER TURNED M WITH LONG LEG]
				case '\u0271': // …±  [LATIN SMALL LETTER M WITH HOOK]
				case '\u1D6F': // ·µØ  [LATIN SMALL LETTER M WITH MIDDLE TILDE]
				case '\u1D86': // ·∂Ü  [LATIN SMALL LETTER M WITH PALATAL HOOK]
				case '\u1E3F': // ·∏ø  [LATIN SMALL LETTER M WITH ACUTE]
				case '\u1E41': // ·πÅ  [LATIN SMALL LETTER M WITH DOT ABOVE]
				case '\u1E43': // ·πÉ  [LATIN SMALL LETTER M WITH DOT BELOW]
				case '\u24DC': // ‚ìú  [CIRCLED LATIN SMALL LETTER M]
				case '\uFF4D': // ÔΩç  [FULLWIDTH LATIN SMALL LETTER M]
					output[outputPos++] = 'm';
					break;
				case '\u24A8': // ‚í®  [PARENTHESIZED LATIN SMALL LETTER M]
					output[outputPos++] = '(';
					output[outputPos++] = 'm';
					output[outputPos++] = ')';
					break;
				case '\u00D1': // √ë  [LATIN CAPITAL LETTER N WITH TILDE]
				case '\u0143': // ≈É  [LATIN CAPITAL LETTER N WITH ACUTE]
				case '\u0145': // ≈Ö  [LATIN CAPITAL LETTER N WITH CEDILLA]
				case '\u0147': // ≈á  [LATIN CAPITAL LETTER N WITH CARON]
				case '\u014A': // ≈ä  http://en.wikipedia.org/wiki/Eng_(letter)  [LATIN CAPITAL LETTER ENG]
				case '\u019D': // ∆ù  [LATIN CAPITAL LETTER N WITH LEFT HOOK]
				case '\u01F8': // «∏  [LATIN CAPITAL LETTER N WITH GRAVE]
				case '\u0220': // »†  [LATIN CAPITAL LETTER N WITH LONG RIGHT LEG]
				case '\u0274': // …¥  [LATIN LETTER SMALL CAPITAL N]
				case '\u1D0E': // ·¥é  [LATIN LETTER SMALL CAPITAL REVERSED N]
				case '\u1E44': // ·πÑ  [LATIN CAPITAL LETTER N WITH DOT ABOVE]
				case '\u1E46': // ·πÜ  [LATIN CAPITAL LETTER N WITH DOT BELOW]
				case '\u1E48': // ·πà  [LATIN CAPITAL LETTER N WITH LINE BELOW]
				case '\u1E4A': // ·πä  [LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW]
				case '\u24C3': // ‚ìÉ  [CIRCLED LATIN CAPITAL LETTER N]
				case '\uFF2E': // ÔºÆ  [FULLWIDTH LATIN CAPITAL LETTER N]
					output[outputPos++] = 'N';
					break;
				case '\u00F1': // √±  [LATIN SMALL LETTER N WITH TILDE]
				case '\u0144': // ≈Ñ  [LATIN SMALL LETTER N WITH ACUTE]
				case '\u0146': // ≈Ü  [LATIN SMALL LETTER N WITH CEDILLA]
				case '\u0148': // ≈à  [LATIN SMALL LETTER N WITH CARON]
				case '\u0149': // ≈â  [LATIN SMALL LETTER N PRECEDED BY APOSTROPHE]
				case '\u014B': // ≈ã  http://en.wikipedia.org/wiki/Eng_(letter)  [LATIN SMALL LETTER ENG]
				case '\u019E': // ∆û  [LATIN SMALL LETTER N WITH LONG RIGHT LEG]
				case '\u01F9': // «π  [LATIN SMALL LETTER N WITH GRAVE]
				case '\u0235': // »µ  [LATIN SMALL LETTER N WITH CURL]
				case '\u0272': // …≤  [LATIN SMALL LETTER N WITH LEFT HOOK]
				case '\u0273': // …≥  [LATIN SMALL LETTER N WITH RETROFLEX HOOK]
				case '\u1D70': // ·µ∞  [LATIN SMALL LETTER N WITH MIDDLE TILDE]
				case '\u1D87': // ·∂á  [LATIN SMALL LETTER N WITH PALATAL HOOK]
				case '\u1E45': // ·πÖ  [LATIN SMALL LETTER N WITH DOT ABOVE]
				case '\u1E47': // ·πá  [LATIN SMALL LETTER N WITH DOT BELOW]
				case '\u1E49': // ·πâ  [LATIN SMALL LETTER N WITH LINE BELOW]
				case '\u1E4B': // ·πã  [LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW]
				case '\u207F': // ‚Åø  [SUPERSCRIPT LATIN SMALL LETTER N]
				case '\u24DD': // ‚ìù  [CIRCLED LATIN SMALL LETTER N]
				case '\uFF4E': // ÔΩé  [FULLWIDTH LATIN SMALL LETTER N]
					output[outputPos++] = 'n';
					break;
				case '\u01CA': // «ä  [LATIN CAPITAL LETTER NJ]
					output[outputPos++] = 'N';
					output[outputPos++] = 'J';
					break;
				case '\u01CB': // «ã  [LATIN CAPITAL LETTER N WITH SMALL LETTER J]
					output[outputPos++] = 'N';
					output[outputPos++] = 'j';
					break;
				case '\u24A9': // ‚í©  [PARENTHESIZED LATIN SMALL LETTER N]
					output[outputPos++] = '(';
					output[outputPos++] = 'n';
					output[outputPos++] = ')';
					break;
				case '\u01CC': // «å  [LATIN SMALL LETTER NJ]
					output[outputPos++] = 'n';
					output[outputPos++] = 'j';
					break;
				case '\u00D2': // √í  [LATIN CAPITAL LETTER O WITH GRAVE]
				case '\u00D3': // √ì  [LATIN CAPITAL LETTER O WITH ACUTE]
				case '\u00D4': // √î  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX]
				case '\u00D5': // √ï  [LATIN CAPITAL LETTER O WITH TILDE]
				case '\u00D6': // √ñ  [LATIN CAPITAL LETTER O WITH DIAERESIS]
				case '\u00D8': // √ò  [LATIN CAPITAL LETTER O WITH STROKE]
				case '\u014C': // ≈å  [LATIN CAPITAL LETTER O WITH MACRON]
				case '\u014E': // ≈é  [LATIN CAPITAL LETTER O WITH BREVE]
				case '\u0150': // ≈ê  [LATIN CAPITAL LETTER O WITH DOUBLE ACUTE]
				case '\u0186': // ∆Ü  [LATIN CAPITAL LETTER OPEN O]
				case '\u019F': // ∆ü  [LATIN CAPITAL LETTER O WITH MIDDLE TILDE]
				case '\u01A0': // ∆†  [LATIN CAPITAL LETTER O WITH HORN]
				case '\u01D1': // «ë  [LATIN CAPITAL LETTER O WITH CARON]
				case '\u01EA': // «™  [LATIN CAPITAL LETTER O WITH OGONEK]
				case '\u01EC': // «¨  [LATIN CAPITAL LETTER O WITH OGONEK AND MACRON]
				case '\u01FE': // «æ  [LATIN CAPITAL LETTER O WITH STROKE AND ACUTE]
				case '\u020C': // »å  [LATIN CAPITAL LETTER O WITH DOUBLE GRAVE]
				case '\u020E': // »é  [LATIN CAPITAL LETTER O WITH INVERTED BREVE]
				case '\u022A': // »™  [LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON]
				case '\u022C': // »¨  [LATIN CAPITAL LETTER O WITH TILDE AND MACRON]
				case '\u022E': // »Æ  [LATIN CAPITAL LETTER O WITH DOT ABOVE]
				case '\u0230': // »∞  [LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON]
				case '\u1D0F': // ·¥è  [LATIN LETTER SMALL CAPITAL O]
				case '\u1D10': // ·¥ê  [LATIN LETTER SMALL CAPITAL OPEN O]
				case '\u1E4C': // ·πå  [LATIN CAPITAL LETTER O WITH TILDE AND ACUTE]
				case '\u1E4E': // ·πé  [LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS]
				case '\u1E50': // ·πê  [LATIN CAPITAL LETTER O WITH MACRON AND GRAVE]
				case '\u1E52': // ·πí  [LATIN CAPITAL LETTER O WITH MACRON AND ACUTE]
				case '\u1ECC': // ·ªå  [LATIN CAPITAL LETTER O WITH DOT BELOW]
				case '\u1ECE': // ·ªé  [LATIN CAPITAL LETTER O WITH HOOK ABOVE]
				case '\u1ED0': // ·ªê  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE]
				case '\u1ED2': // ·ªí  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE]
				case '\u1ED4': // ·ªî  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1ED6': // ·ªñ  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE]
				case '\u1ED8': // ·ªò  [LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW]
				case '\u1EDA': // ·ªö  [LATIN CAPITAL LETTER O WITH HORN AND ACUTE]
				case '\u1EDC': // ·ªú  [LATIN CAPITAL LETTER O WITH HORN AND GRAVE]
				case '\u1EDE': // ·ªû  [LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE]
				case '\u1EE0': // ·ª†  [LATIN CAPITAL LETTER O WITH HORN AND TILDE]
				case '\u1EE2': // ·ª¢  [LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW]
				case '\u24C4': // ‚ìÑ  [CIRCLED LATIN CAPITAL LETTER O]
				case '\uA74A': // Íùä  [LATIN CAPITAL LETTER O WITH LONG STROKE OVERLAY]
				case '\uA74C': // Íùå  [LATIN CAPITAL LETTER O WITH LOOP]
				case '\uFF2F': // ÔºØ  [FULLWIDTH LATIN CAPITAL LETTER O]
					output[outputPos++] = 'O';
					break;
				case '\u00F2': // √≤  [LATIN SMALL LETTER O WITH GRAVE]
				case '\u00F3': // √≥  [LATIN SMALL LETTER O WITH ACUTE]
				case '\u00F4': // √¥  [LATIN SMALL LETTER O WITH CIRCUMFLEX]
				case '\u00F5': // √µ  [LATIN SMALL LETTER O WITH TILDE]
				case '\u00F6': // √∂  [LATIN SMALL LETTER O WITH DIAERESIS]
				case '\u00F8': // √∏  [LATIN SMALL LETTER O WITH STROKE]
				case '\u014D': // ≈ç  [LATIN SMALL LETTER O WITH MACRON]
				case '\u014F': // ≈è  [LATIN SMALL LETTER O WITH BREVE]
				case '\u0151': // ≈ë  [LATIN SMALL LETTER O WITH DOUBLE ACUTE]
				case '\u01A1': // ∆°  [LATIN SMALL LETTER O WITH HORN]
				case '\u01D2': // «í  [LATIN SMALL LETTER O WITH CARON]
				case '\u01EB': // «´  [LATIN SMALL LETTER O WITH OGONEK]
				case '\u01ED': // «≠  [LATIN SMALL LETTER O WITH OGONEK AND MACRON]
				case '\u01FF': // «ø  [LATIN SMALL LETTER O WITH STROKE AND ACUTE]
				case '\u020D': // »ç  [LATIN SMALL LETTER O WITH DOUBLE GRAVE]
				case '\u020F': // »è  [LATIN SMALL LETTER O WITH INVERTED BREVE]
				case '\u022B': // »´  [LATIN SMALL LETTER O WITH DIAERESIS AND MACRON]
				case '\u022D': // »≠  [LATIN SMALL LETTER O WITH TILDE AND MACRON]
				case '\u022F': // »Ø  [LATIN SMALL LETTER O WITH DOT ABOVE]
				case '\u0231': // »±  [LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON]
				case '\u0254': // …î  [LATIN SMALL LETTER OPEN O]
				case '\u0275': // …µ  [LATIN SMALL LETTER BARRED O]
				case '\u1D16': // ·¥ñ  [LATIN SMALL LETTER TOP HALF O]
				case '\u1D17': // ·¥ó  [LATIN SMALL LETTER BOTTOM HALF O]
				case '\u1D97': // ·∂ó  [LATIN SMALL LETTER OPEN O WITH RETROFLEX HOOK]
				case '\u1E4D': // ·πç  [LATIN SMALL LETTER O WITH TILDE AND ACUTE]
				case '\u1E4F': // ·πè  [LATIN SMALL LETTER O WITH TILDE AND DIAERESIS]
				case '\u1E51': // ·πë  [LATIN SMALL LETTER O WITH MACRON AND GRAVE]
				case '\u1E53': // ·πì  [LATIN SMALL LETTER O WITH MACRON AND ACUTE]
				case '\u1ECD': // ·ªç  [LATIN SMALL LETTER O WITH DOT BELOW]
				case '\u1ECF': // ·ªè  [LATIN SMALL LETTER O WITH HOOK ABOVE]
				case '\u1ED1': // ·ªë  [LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE]
				case '\u1ED3': // ·ªì  [LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE]
				case '\u1ED5': // ·ªï  [LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE]
				case '\u1ED7': // ·ªó  [LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE]
				case '\u1ED9': // ·ªô  [LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW]
				case '\u1EDB': // ·ªõ  [LATIN SMALL LETTER O WITH HORN AND ACUTE]
				case '\u1EDD': // ·ªù  [LATIN SMALL LETTER O WITH HORN AND GRAVE]
				case '\u1EDF': // ·ªü  [LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE]
				case '\u1EE1': // ·ª°  [LATIN SMALL LETTER O WITH HORN AND TILDE]
				case '\u1EE3': // ·ª£  [LATIN SMALL LETTER O WITH HORN AND DOT BELOW]
				case '\u2092': // ‚Çí  [LATIN SUBSCRIPT SMALL LETTER O]
				case '\u24DE': // ‚ìû  [CIRCLED LATIN SMALL LETTER O]
				case '\u2C7A': // ‚±∫  [LATIN SMALL LETTER O WITH LOW RING INSIDE]
				case '\uA74B': // Íùã  [LATIN SMALL LETTER O WITH LONG STROKE OVERLAY]
				case '\uA74D': // Íùç  [LATIN SMALL LETTER O WITH LOOP]
				case '\uFF4F': // ÔΩè  [FULLWIDTH LATIN SMALL LETTER O]
					output[outputPos++] = 'o';
					break;
				case '\u0152': // ≈í  [LATIN CAPITAL LIGATURE OE]
				case '\u0276': // …∂  [LATIN LETTER SMALL CAPITAL OE]
					output[outputPos++] = 'O';
					output[outputPos++] = 'E';
					break;
				case '\uA74E': // Íùé  [LATIN CAPITAL LETTER OO]
					output[outputPos++] = 'O';
					output[outputPos++] = 'O';
					break;
				case '\u0222': // »¢  http://en.wikipedia.org/wiki/OU  [LATIN CAPITAL LETTER OU]
				case '\u1D15': // ·¥ï  [LATIN LETTER SMALL CAPITAL OU]
					output[outputPos++] = 'O';
					output[outputPos++] = 'U';
					break;
				case '\u24AA': // ‚í™  [PARENTHESIZED LATIN SMALL LETTER O]
					output[outputPos++] = '(';
					output[outputPos++] = 'o';
					output[outputPos++] = ')';
					break;
				case '\u0153': // ≈ì  [LATIN SMALL LIGATURE OE]
				case '\u1D14': // ·¥î  [LATIN SMALL LETTER TURNED OE]
					output[outputPos++] = 'o';
					output[outputPos++] = 'e';
					break;
				case '\uA74F': // Íùè  [LATIN SMALL LETTER OO]
					output[outputPos++] = 'o';
					output[outputPos++] = 'o';
					break;
				case '\u0223': // »£  http://en.wikipedia.org/wiki/OU  [LATIN SMALL LETTER OU]
					output[outputPos++] = 'o';
					output[outputPos++] = 'u';
					break;
				case '\u01A4': // ∆§  [LATIN CAPITAL LETTER P WITH HOOK]
				case '\u1D18': // ·¥ò  [LATIN LETTER SMALL CAPITAL P]
				case '\u1E54': // ·πî  [LATIN CAPITAL LETTER P WITH ACUTE]
				case '\u1E56': // ·πñ  [LATIN CAPITAL LETTER P WITH DOT ABOVE]
				case '\u24C5': // ‚ìÖ  [CIRCLED LATIN CAPITAL LETTER P]
				case '\u2C63': // ‚±£  [LATIN CAPITAL LETTER P WITH STROKE]
				case '\uA750': // Íùê  [LATIN CAPITAL LETTER P WITH STROKE THROUGH DESCENDER]
				case '\uA752': // Íùí  [LATIN CAPITAL LETTER P WITH FLOURISH]
				case '\uA754': // Íùî  [LATIN CAPITAL LETTER P WITH SQUIRREL TAIL]
				case '\uFF30': // Ôº∞  [FULLWIDTH LATIN CAPITAL LETTER P]
					output[outputPos++] = 'P';
					break;
				case '\u01A5': // ∆•  [LATIN SMALL LETTER P WITH HOOK]
				case '\u1D71': // ·µ±  [LATIN SMALL LETTER P WITH MIDDLE TILDE]
				case '\u1D7D': // ·µΩ  [LATIN SMALL LETTER P WITH STROKE]
				case '\u1D88': // ·∂à  [LATIN SMALL LETTER P WITH PALATAL HOOK]
				case '\u1E55': // ·πï  [LATIN SMALL LETTER P WITH ACUTE]
				case '\u1E57': // ·πó  [LATIN SMALL LETTER P WITH DOT ABOVE]
				case '\u24DF': // ‚ìü  [CIRCLED LATIN SMALL LETTER P]
				case '\uA751': // Íùë  [LATIN SMALL LETTER P WITH STROKE THROUGH DESCENDER]
				case '\uA753': // Íùì  [LATIN SMALL LETTER P WITH FLOURISH]
				case '\uA755': // Íùï  [LATIN SMALL LETTER P WITH SQUIRREL TAIL]
				case '\uA7FC': // Íüº  [LATIN EPIGRAPHIC LETTER REVERSED P]
				case '\uFF50': // ÔΩê  [FULLWIDTH LATIN SMALL LETTER P]
					output[outputPos++] = 'p';
					break;
				case '\u24AB': // ‚í´  [PARENTHESIZED LATIN SMALL LETTER P]
					output[outputPos++] = '(';
					output[outputPos++] = 'p';
					output[outputPos++] = ')';
					break;
				case '\u024A': // …ä  [LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL]
				case '\u24C6': // ‚ìÜ  [CIRCLED LATIN CAPITAL LETTER Q]
				case '\uA756': // Íùñ  [LATIN CAPITAL LETTER Q WITH STROKE THROUGH DESCENDER]
				case '\uA758': // Íùò  [LATIN CAPITAL LETTER Q WITH DIAGONAL STROKE]
				case '\uFF31': // Ôº±  [FULLWIDTH LATIN CAPITAL LETTER Q]
					output[outputPos++] = 'Q';
					break;
				case '\u0138': // ƒ∏  http://en.wikipedia.org/wiki/Kra_(letter)  [LATIN SMALL LETTER KRA]
				case '\u024B': // …ã  [LATIN SMALL LETTER Q WITH HOOK TAIL]
				case '\u02A0': //  †  [LATIN SMALL LETTER Q WITH HOOK]
				case '\u24E0': // ‚ì†  [CIRCLED LATIN SMALL LETTER Q]
				case '\uA757': // Íùó  [LATIN SMALL LETTER Q WITH STROKE THROUGH DESCENDER]
				case '\uA759': // Íùô  [LATIN SMALL LETTER Q WITH DIAGONAL STROKE]
				case '\uFF51': // ÔΩë  [FULLWIDTH LATIN SMALL LETTER Q]
					output[outputPos++] = 'q';
					break;
				case '\u24AC': // ‚í¨  [PARENTHESIZED LATIN SMALL LETTER Q]
					output[outputPos++] = '(';
					output[outputPos++] = 'q';
					output[outputPos++] = ')';
					break;
				case '\u0239': // »π  [LATIN SMALL LETTER QP DIGRAPH]
					output[outputPos++] = 'q';
					output[outputPos++] = 'p';
					break;
				case '\u0154': // ≈î  [LATIN CAPITAL LETTER R WITH ACUTE]
				case '\u0156': // ≈ñ  [LATIN CAPITAL LETTER R WITH CEDILLA]
				case '\u0158': // ≈ò  [LATIN CAPITAL LETTER R WITH CARON]
				case '\u0210': // »í  [LATIN CAPITAL LETTER R WITH DOUBLE GRAVE]
				case '\u0212': // »í  [LATIN CAPITAL LETTER R WITH INVERTED BREVE]
				case '\u024C': // …å  [LATIN CAPITAL LETTER R WITH STROKE]
				case '\u0280': //  Ä  [LATIN LETTER SMALL CAPITAL R]
				case '\u0281': //  Å  [LATIN LETTER SMALL CAPITAL INVERTED R]
				case '\u1D19': // ·¥ô  [LATIN LETTER SMALL CAPITAL REVERSED R]
				case '\u1D1A': // ·¥ö  [LATIN LETTER SMALL CAPITAL TURNED R]
				case '\u1E58': // ·πò  [LATIN CAPITAL LETTER R WITH DOT ABOVE]
				case '\u1E5A': // ·πö  [LATIN CAPITAL LETTER R WITH DOT BELOW]
				case '\u1E5C': // ·πú  [LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON]
				case '\u1E5E': // ·πû  [LATIN CAPITAL LETTER R WITH LINE BELOW]
				case '\u24C7': // ‚ìá  [CIRCLED LATIN CAPITAL LETTER R]
				case '\u2C64': // ‚±§  [LATIN CAPITAL LETTER R WITH TAIL]
				case '\uA75A': // Íùö  [LATIN CAPITAL LETTER R ROTUNDA]
				case '\uA782': // ÍûÇ  [LATIN CAPITAL LETTER INSULAR R]
				case '\uFF32': // Ôº≤  [FULLWIDTH LATIN CAPITAL LETTER R]
					output[outputPos++] = 'R';
					break;
				case '\u0155': // ≈ï  [LATIN SMALL LETTER R WITH ACUTE]
				case '\u0157': // ≈ó  [LATIN SMALL LETTER R WITH CEDILLA]
				case '\u0159': // ≈ô  [LATIN SMALL LETTER R WITH CARON]
				case '\u0211': // »ë  [LATIN SMALL LETTER R WITH DOUBLE GRAVE]
				case '\u0213': // »ì  [LATIN SMALL LETTER R WITH INVERTED BREVE]
				case '\u024D': // …ç  [LATIN SMALL LETTER R WITH STROKE]
				case '\u027C': // …º  [LATIN SMALL LETTER R WITH LONG LEG]
				case '\u027D': // …Ω  [LATIN SMALL LETTER R WITH TAIL]
				case '\u027E': // …æ  [LATIN SMALL LETTER R WITH FISHHOOK]
				case '\u027F': // …ø  [LATIN SMALL LETTER REVERSED R WITH FISHHOOK]
				case '\u1D63': // ·µ£  [LATIN SUBSCRIPT SMALL LETTER R]
				case '\u1D72': // ·µ≤  [LATIN SMALL LETTER R WITH MIDDLE TILDE]
				case '\u1D73': // ·µ≥  [LATIN SMALL LETTER R WITH FISHHOOK AND MIDDLE TILDE]
				case '\u1D89': // ·∂â  [LATIN SMALL LETTER R WITH PALATAL HOOK]
				case '\u1E59': // ·πô  [LATIN SMALL LETTER R WITH DOT ABOVE]
				case '\u1E5B': // ·πõ  [LATIN SMALL LETTER R WITH DOT BELOW]
				case '\u1E5D': // ·πù  [LATIN SMALL LETTER R WITH DOT BELOW AND MACRON]
				case '\u1E5F': // ·πü  [LATIN SMALL LETTER R WITH LINE BELOW]
				case '\u24E1': // ‚ì°  [CIRCLED LATIN SMALL LETTER R]
				case '\uA75B': // Íùõ  [LATIN SMALL LETTER R ROTUNDA]
				case '\uA783': // ÍûÉ  [LATIN SMALL LETTER INSULAR R]
				case '\uFF52': // ÔΩí  [FULLWIDTH LATIN SMALL LETTER R]
					output[outputPos++] = 'r';
					break;
				case '\u24AD': // ‚í≠  [PARENTHESIZED LATIN SMALL LETTER R]
					output[outputPos++] = '(';
					output[outputPos++] = 'r';
					output[outputPos++] = ')';
					break;
				case '\u015A': // ≈ö  [LATIN CAPITAL LETTER S WITH ACUTE]
				case '\u015C': // ≈ú  [LATIN CAPITAL LETTER S WITH CIRCUMFLEX]
				case '\u015E': // ≈û  [LATIN CAPITAL LETTER S WITH CEDILLA]
				case '\u0160': // ≈†  [LATIN CAPITAL LETTER S WITH CARON]
				case '\u0218': // »ò  [LATIN CAPITAL LETTER S WITH COMMA BELOW]
				case '\u1E60': // ·π†  [LATIN CAPITAL LETTER S WITH DOT ABOVE]
				case '\u1E62': // ·π¢  [LATIN CAPITAL LETTER S WITH DOT BELOW]
				case '\u1E64': // ·π§  [LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE]
				case '\u1E66': // ·π¶  [LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE]
				case '\u1E68': // ·π®  [LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE]
				case '\u24C8': // ‚ìà  [CIRCLED LATIN CAPITAL LETTER S]
				case '\uA731': // Íú±  [LATIN LETTER SMALL CAPITAL S]
				case '\uA785': // ÍûÖ  [LATIN SMALL LETTER INSULAR S]
				case '\uFF33': // Ôº≥  [FULLWIDTH LATIN CAPITAL LETTER S]
					output[outputPos++] = 'S';
					break;
				case '\u015B': // ≈õ  [LATIN SMALL LETTER S WITH ACUTE]
				case '\u015D': // ≈ù  [LATIN SMALL LETTER S WITH CIRCUMFLEX]
				case '\u015F': // ≈ü  [LATIN SMALL LETTER S WITH CEDILLA]
				case '\u0161': // ≈°  [LATIN SMALL LETTER S WITH CARON]
				case '\u017F': // ≈ø  http://en.wikipedia.org/wiki/Long_S  [LATIN SMALL LETTER LONG S]
				case '\u0219': // »ô  [LATIN SMALL LETTER S WITH COMMA BELOW]
				case '\u023F': // »ø  [LATIN SMALL LETTER S WITH SWASH TAIL]
				case '\u0282': //  Ç  [LATIN SMALL LETTER S WITH HOOK]
				case '\u1D74': // ·µ¥  [LATIN SMALL LETTER S WITH MIDDLE TILDE]
				case '\u1D8A': // ·∂ä  [LATIN SMALL LETTER S WITH PALATAL HOOK]
				case '\u1E61': // ·π°  [LATIN SMALL LETTER S WITH DOT ABOVE]
				case '\u1E63': // ·π£  [LATIN SMALL LETTER S WITH DOT BELOW]
				case '\u1E65': // ·π•  [LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE]
				case '\u1E67': // ·πß  [LATIN SMALL LETTER S WITH CARON AND DOT ABOVE]
				case '\u1E69': // ·π©  [LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE]
				case '\u1E9C': // ·∫ú  [LATIN SMALL LETTER LONG S WITH DIAGONAL STROKE]
				case '\u1E9D': // ·∫ù  [LATIN SMALL LETTER LONG S WITH HIGH STROKE]
				case '\u24E2': // ‚ì¢  [CIRCLED LATIN SMALL LETTER S]
				case '\uA784': // ÍûÑ  [LATIN CAPITAL LETTER INSULAR S]
				case '\uFF53': // ÔΩì  [FULLWIDTH LATIN SMALL LETTER S]
					output[outputPos++] = 's';
					break;
				case '\u1E9E': // ·∫û  [LATIN CAPITAL LETTER SHARP S]
					output[outputPos++] = 'S';
					output[outputPos++] = 'S';
					break;
				case '\u24AE': // ‚íÆ  [PARENTHESIZED LATIN SMALL LETTER S]
					output[outputPos++] = '(';
					output[outputPos++] = 's';
					output[outputPos++] = ')';
					break;
				case '\u00DF': // √ü  [LATIN SMALL LETTER SHARP S]
					output[outputPos++] = 's';
					output[outputPos++] = 's';
					break;
				case '\uFB06': // Ô¨Ü  [LATIN SMALL LIGATURE ST]
					output[outputPos++] = 's';
					output[outputPos++] = 't';
					break;
				case '\u0162': // ≈¢  [LATIN CAPITAL LETTER T WITH CEDILLA]
				case '\u0164': // ≈§  [LATIN CAPITAL LETTER T WITH CARON]
				case '\u0166': // ≈¶  [LATIN CAPITAL LETTER T WITH STROKE]
				case '\u01AC': // ∆¨  [LATIN CAPITAL LETTER T WITH HOOK]
				case '\u01AE': // ∆Æ  [LATIN CAPITAL LETTER T WITH RETROFLEX HOOK]
				case '\u021A': // »ö  [LATIN CAPITAL LETTER T WITH COMMA BELOW]
				case '\u023E': // »æ  [LATIN CAPITAL LETTER T WITH DIAGONAL STROKE]
				case '\u1D1B': // ·¥õ  [LATIN LETTER SMALL CAPITAL T]
				case '\u1E6A': // ·π™  [LATIN CAPITAL LETTER T WITH DOT ABOVE]
				case '\u1E6C': // ·π¨  [LATIN CAPITAL LETTER T WITH DOT BELOW]
				case '\u1E6E': // ·πÆ  [LATIN CAPITAL LETTER T WITH LINE BELOW]
				case '\u1E70': // ·π∞  [LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW]
				case '\u24C9': // ‚ìâ  [CIRCLED LATIN CAPITAL LETTER T]
				case '\uA786': // ÍûÜ  [LATIN CAPITAL LETTER INSULAR T]
				case '\uFF34': // Ôº¥  [FULLWIDTH LATIN CAPITAL LETTER T]
					output[outputPos++] = 'T';
					break;
				case '\u0163': // ≈£  [LATIN SMALL LETTER T WITH CEDILLA]
				case '\u0165': // ≈•  [LATIN SMALL LETTER T WITH CARON]
				case '\u0167': // ≈ß  [LATIN SMALL LETTER T WITH STROKE]
				case '\u01AB': // ∆´  [LATIN SMALL LETTER T WITH PALATAL HOOK]
				case '\u01AD': // ∆≠  [LATIN SMALL LETTER T WITH HOOK]
				case '\u021B': // »õ  [LATIN SMALL LETTER T WITH COMMA BELOW]
				case '\u0236': // »∂  [LATIN SMALL LETTER T WITH CURL]
				case '\u0287': //  á  [LATIN SMALL LETTER TURNED T]
				case '\u0288': //  à  [LATIN SMALL LETTER T WITH RETROFLEX HOOK]
				case '\u1D75': // ·µµ  [LATIN SMALL LETTER T WITH MIDDLE TILDE]
				case '\u1E6B': // ·π´  [LATIN SMALL LETTER T WITH DOT ABOVE]
				case '\u1E6D': // ·π≠  [LATIN SMALL LETTER T WITH DOT BELOW]
				case '\u1E6F': // ·πØ  [LATIN SMALL LETTER T WITH LINE BELOW]
				case '\u1E71': // ·π±  [LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW]
				case '\u1E97': // ·∫ó  [LATIN SMALL LETTER T WITH DIAERESIS]
				case '\u24E3': // ‚ì£  [CIRCLED LATIN SMALL LETTER T]
				case '\u2C66': // ‚±¶  [LATIN SMALL LETTER T WITH DIAGONAL STROKE]
				case '\uFF54': // ÔΩî  [FULLWIDTH LATIN SMALL LETTER T]
					output[outputPos++] = 't';
					break;
				case '\u00DE': // √û  [LATIN CAPITAL LETTER THORN]
				case '\uA766': // Íù¶  [LATIN CAPITAL LETTER THORN WITH STROKE THROUGH DESCENDER]
					output[outputPos++] = 'T';
					output[outputPos++] = 'H';
					break;
				case '\uA728': // Íú®  [LATIN CAPITAL LETTER TZ]
					output[outputPos++] = 'T';
					output[outputPos++] = 'Z';
					break;
				case '\u24AF': // ‚íØ  [PARENTHESIZED LATIN SMALL LETTER T]
					output[outputPos++] = '(';
					output[outputPos++] = 't';
					output[outputPos++] = ')';
					break;
				case '\u02A8': //  ®  [LATIN SMALL LETTER TC DIGRAPH WITH CURL]
					output[outputPos++] = 't';
					output[outputPos++] = 'c';
					break;
				case '\u00FE': // √æ  [LATIN SMALL LETTER THORN]
				case '\u1D7A': // ·µ∫  [LATIN SMALL LETTER TH WITH STRIKETHROUGH]
				case '\uA767': // Íùß  [LATIN SMALL LETTER THORN WITH STROKE THROUGH DESCENDER]
					output[outputPos++] = 't';
					output[outputPos++] = 'h';
					break;
				case '\u02A6': //  ¶  [LATIN SMALL LETTER TS DIGRAPH]
					output[outputPos++] = 't';
					output[outputPos++] = 's';
					break;
				case '\uA729': // Íú©  [LATIN SMALL LETTER TZ]
					output[outputPos++] = 't';
					output[outputPos++] = 'z';
					break;
				case '\u00D9': // √ô  [LATIN CAPITAL LETTER U WITH GRAVE]
				case '\u00DA': // √ö  [LATIN CAPITAL LETTER U WITH ACUTE]
				case '\u00DB': // √õ  [LATIN CAPITAL LETTER U WITH CIRCUMFLEX]
				case '\u00DC': // √ú  [LATIN CAPITAL LETTER U WITH DIAERESIS]
				case '\u0168': // ≈®  [LATIN CAPITAL LETTER U WITH TILDE]
				case '\u016A': // ≈™  [LATIN CAPITAL LETTER U WITH MACRON]
				case '\u016C': // ≈¨  [LATIN CAPITAL LETTER U WITH BREVE]
				case '\u016E': // ≈Æ  [LATIN CAPITAL LETTER U WITH RING ABOVE]
				case '\u0170': // ≈∞  [LATIN CAPITAL LETTER U WITH DOUBLE ACUTE]
				case '\u0172': // ≈≤  [LATIN CAPITAL LETTER U WITH OGONEK]
				case '\u01AF': // ∆Ø  [LATIN CAPITAL LETTER U WITH HORN]
				case '\u01D3': // «ì  [LATIN CAPITAL LETTER U WITH CARON]
				case '\u01D5': // «ï  [LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON]
				case '\u01D7': // «ó  [LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE]
				case '\u01D9': // «ô  [LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON]
				case '\u01DB': // «õ  [LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE]
				case '\u0214': // »î  [LATIN CAPITAL LETTER U WITH DOUBLE GRAVE]
				case '\u0216': // »ñ  [LATIN CAPITAL LETTER U WITH INVERTED BREVE]
				case '\u0244': // …Ñ  [LATIN CAPITAL LETTER U BAR]
				case '\u1D1C': // ·¥ú  [LATIN LETTER SMALL CAPITAL U]
				case '\u1D7E': // ·µæ  [LATIN SMALL CAPITAL LETTER U WITH STROKE]
				case '\u1E72': // ·π≤  [LATIN CAPITAL LETTER U WITH DIAERESIS BELOW]
				case '\u1E74': // ·π¥  [LATIN CAPITAL LETTER U WITH TILDE BELOW]
				case '\u1E76': // ·π∂  [LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW]
				case '\u1E78': // ·π∏  [LATIN CAPITAL LETTER U WITH TILDE AND ACUTE]
				case '\u1E7A': // ·π∫  [LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS]
				case '\u1EE4': // ·ª§  [LATIN CAPITAL LETTER U WITH DOT BELOW]
				case '\u1EE6': // ·ª¶  [LATIN CAPITAL LETTER U WITH HOOK ABOVE]
				case '\u1EE8': // ·ª®  [LATIN CAPITAL LETTER U WITH HORN AND ACUTE]
				case '\u1EEA': // ·ª™  [LATIN CAPITAL LETTER U WITH HORN AND GRAVE]
				case '\u1EEC': // ·ª¨  [LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE]
				case '\u1EEE': // ·ªÆ  [LATIN CAPITAL LETTER U WITH HORN AND TILDE]
				case '\u1EF0': // ·ª∞  [LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW]
				case '\u24CA': // ‚ìä  [CIRCLED LATIN CAPITAL LETTER U]
				case '\uFF35': // Ôºµ  [FULLWIDTH LATIN CAPITAL LETTER U]
					output[outputPos++] = 'U';
					break;
				case '\u00F9': // √π  [LATIN SMALL LETTER U WITH GRAVE]
				case '\u00FA': // √∫  [LATIN SMALL LETTER U WITH ACUTE]
				case '\u00FB': // √ª  [LATIN SMALL LETTER U WITH CIRCUMFLEX]
				case '\u00FC': // √º  [LATIN SMALL LETTER U WITH DIAERESIS]
				case '\u0169': // ≈©  [LATIN SMALL LETTER U WITH TILDE]
				case '\u016B': // ≈´  [LATIN SMALL LETTER U WITH MACRON]
				case '\u016D': // ≈≠  [LATIN SMALL LETTER U WITH BREVE]
				case '\u016F': // ≈Ø  [LATIN SMALL LETTER U WITH RING ABOVE]
				case '\u0171': // ≈±  [LATIN SMALL LETTER U WITH DOUBLE ACUTE]
				case '\u0173': // ≈≥  [LATIN SMALL LETTER U WITH OGONEK]
				case '\u01B0': // ∆∞  [LATIN SMALL LETTER U WITH HORN]
				case '\u01D4': // «î  [LATIN SMALL LETTER U WITH CARON]
				case '\u01D6': // «ñ  [LATIN SMALL LETTER U WITH DIAERESIS AND MACRON]
				case '\u01D8': // «ò  [LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE]
				case '\u01DA': // «ö  [LATIN SMALL LETTER U WITH DIAERESIS AND CARON]
				case '\u01DC': // «ú  [LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE]
				case '\u0215': // »ï  [LATIN SMALL LETTER U WITH DOUBLE GRAVE]
				case '\u0217': // »ó  [LATIN SMALL LETTER U WITH INVERTED BREVE]
				case '\u0289': //  â  [LATIN SMALL LETTER U BAR]
				case '\u1D64': // ·µ§  [LATIN SUBSCRIPT SMALL LETTER U]
				case '\u1D99': // ·∂ô  [LATIN SMALL LETTER U WITH RETROFLEX HOOK]
				case '\u1E73': // ·π≥  [LATIN SMALL LETTER U WITH DIAERESIS BELOW]
				case '\u1E75': // ·πµ  [LATIN SMALL LETTER U WITH TILDE BELOW]
				case '\u1E77': // ·π∑  [LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW]
				case '\u1E79': // ·ππ  [LATIN SMALL LETTER U WITH TILDE AND ACUTE]
				case '\u1E7B': // ·πª  [LATIN SMALL LETTER U WITH MACRON AND DIAERESIS]
				case '\u1EE5': // ·ª•  [LATIN SMALL LETTER U WITH DOT BELOW]
				case '\u1EE7': // ·ªß  [LATIN SMALL LETTER U WITH HOOK ABOVE]
				case '\u1EE9': // ·ª©  [LATIN SMALL LETTER U WITH HORN AND ACUTE]
				case '\u1EEB': // ·ª´  [LATIN SMALL LETTER U WITH HORN AND GRAVE]
				case '\u1EED': // ·ª≠  [LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE]
				case '\u1EEF': // ·ªØ  [LATIN SMALL LETTER U WITH HORN AND TILDE]
				case '\u1EF1': // ·ª±  [LATIN SMALL LETTER U WITH HORN AND DOT BELOW]
				case '\u24E4': // ‚ì§  [CIRCLED LATIN SMALL LETTER U]
				case '\uFF55': // ÔΩï  [FULLWIDTH LATIN SMALL LETTER U]
					output[outputPos++] = 'u';
					break;
				case '\u24B0': // ‚í∞  [PARENTHESIZED LATIN SMALL LETTER U]
					output[outputPos++] = '(';
					output[outputPos++] = 'u';
					output[outputPos++] = ')';
					break;
				case '\u1D6B': // ·µ´  [LATIN SMALL LETTER UE]
					output[outputPos++] = 'u';
					output[outputPos++] = 'e';
					break;
				case '\u01B2': // ∆≤  [LATIN CAPITAL LETTER V WITH HOOK]
				case '\u0245': // …Ö  [LATIN CAPITAL LETTER TURNED V]
				case '\u1D20': // ·¥†  [LATIN LETTER SMALL CAPITAL V]
				case '\u1E7C': // ·πº  [LATIN CAPITAL LETTER V WITH TILDE]
				case '\u1E7E': // ·πæ  [LATIN CAPITAL LETTER V WITH DOT BELOW]
				case '\u1EFC': // ·ªº  [LATIN CAPITAL LETTER MIDDLE-WELSH V]
				case '\u24CB': // ‚ìã  [CIRCLED LATIN CAPITAL LETTER V]
				case '\uA75E': // Íùû  [LATIN CAPITAL LETTER V WITH DIAGONAL STROKE]
				case '\uA768': // Íù®  [LATIN CAPITAL LETTER VEND]
				case '\uFF36': // Ôº∂  [FULLWIDTH LATIN CAPITAL LETTER V]
					output[outputPos++] = 'V';
					break;
				case '\u028B': //  ã  [LATIN SMALL LETTER V WITH HOOK]
				case '\u028C': //  å  [LATIN SMALL LETTER TURNED V]
				case '\u1D65': // ·µ•  [LATIN SUBSCRIPT SMALL LETTER V]
				case '\u1D8C': // ·∂å  [LATIN SMALL LETTER V WITH PALATAL HOOK]
				case '\u1E7D': // ·πΩ  [LATIN SMALL LETTER V WITH TILDE]
				case '\u1E7F': // ·πø  [LATIN SMALL LETTER V WITH DOT BELOW]
				case '\u24E5': // ‚ì•  [CIRCLED LATIN SMALL LETTER V]
				case '\u2C71': // ‚±±  [LATIN SMALL LETTER V WITH RIGHT HOOK]
				case '\u2C74': // ‚±¥  [LATIN SMALL LETTER V WITH CURL]
				case '\uA75F': // Íùü  [LATIN SMALL LETTER V WITH DIAGONAL STROKE]
				case '\uFF56': // ÔΩñ  [FULLWIDTH LATIN SMALL LETTER V]
					output[outputPos++] = 'v';
					break;
				case '\uA760': // Íù†  [LATIN CAPITAL LETTER VY]
					output[outputPos++] = 'V';
					output[outputPos++] = 'Y';
					break;
				case '\u24B1': // ‚í±  [PARENTHESIZED LATIN SMALL LETTER V]
					output[outputPos++] = '(';
					output[outputPos++] = 'v';
					output[outputPos++] = ')';
					break;
				case '\uA761': // Íù°  [LATIN SMALL LETTER VY]
					output[outputPos++] = 'v';
					output[outputPos++] = 'y';
					break;
				case '\u0174': // ≈¥  [LATIN CAPITAL LETTER W WITH CIRCUMFLEX]
				case '\u01F7': // «∑  http://en.wikipedia.org/wiki/Wynn  [LATIN CAPITAL LETTER WYNN]
				case '\u1D21': // ·¥°  [LATIN LETTER SMALL CAPITAL W]
				case '\u1E80': // ·∫Ä  [LATIN CAPITAL LETTER W WITH GRAVE]
				case '\u1E82': // ·∫Ç  [LATIN CAPITAL LETTER W WITH ACUTE]
				case '\u1E84': // ·∫Ñ  [LATIN CAPITAL LETTER W WITH DIAERESIS]
				case '\u1E86': // ·∫Ü  [LATIN CAPITAL LETTER W WITH DOT ABOVE]
				case '\u1E88': // ·∫à  [LATIN CAPITAL LETTER W WITH DOT BELOW]
				case '\u24CC': // ‚ìå  [CIRCLED LATIN CAPITAL LETTER W]
				case '\u2C72': // ‚±≤  [LATIN CAPITAL LETTER W WITH HOOK]
				case '\uFF37': // Ôº∑  [FULLWIDTH LATIN CAPITAL LETTER W]
					output[outputPos++] = 'W';
					break;
				case '\u0175': // ≈µ  [LATIN SMALL LETTER W WITH CIRCUMFLEX]
				case '\u01BF': // ∆ø  http://en.wikipedia.org/wiki/Wynn  [LATIN LETTER WYNN]
				case '\u028D': //  ç  [LATIN SMALL LETTER TURNED W]
				case '\u1E81': // ·∫Å  [LATIN SMALL LETTER W WITH GRAVE]
				case '\u1E83': // ·∫É  [LATIN SMALL LETTER W WITH ACUTE]
				case '\u1E85': // ·∫Ö  [LATIN SMALL LETTER W WITH DIAERESIS]
				case '\u1E87': // ·∫á  [LATIN SMALL LETTER W WITH DOT ABOVE]
				case '\u1E89': // ·∫â  [LATIN SMALL LETTER W WITH DOT BELOW]
				case '\u1E98': // ·∫ò  [LATIN SMALL LETTER W WITH RING ABOVE]
				case '\u24E6': // ‚ì¶  [CIRCLED LATIN SMALL LETTER W]
				case '\u2C73': // ‚±≥  [LATIN SMALL LETTER W WITH HOOK]
				case '\uFF57': // ÔΩó  [FULLWIDTH LATIN SMALL LETTER W]
					output[outputPos++] = 'w';
					break;
				case '\u24B2': // ‚í≤  [PARENTHESIZED LATIN SMALL LETTER W]
					output[outputPos++] = '(';
					output[outputPos++] = 'w';
					output[outputPos++] = ')';
					break;
				case '\u1E8A': // ·∫ä  [LATIN CAPITAL LETTER X WITH DOT ABOVE]
				case '\u1E8C': // ·∫å  [LATIN CAPITAL LETTER X WITH DIAERESIS]
				case '\u24CD': // ‚ìç  [CIRCLED LATIN CAPITAL LETTER X]
				case '\uFF38': // Ôº∏  [FULLWIDTH LATIN CAPITAL LETTER X]
					output[outputPos++] = 'X';
					break;
				case '\u1D8D': // ·∂ç  [LATIN SMALL LETTER X WITH PALATAL HOOK]
				case '\u1E8B': // ·∫ã  [LATIN SMALL LETTER X WITH DOT ABOVE]
				case '\u1E8D': // ·∫ç  [LATIN SMALL LETTER X WITH DIAERESIS]
				case '\u2093': // ‚Çì  [LATIN SUBSCRIPT SMALL LETTER X]
				case '\u24E7': // ‚ìß  [CIRCLED LATIN SMALL LETTER X]
				case '\uFF58': // ÔΩò  [FULLWIDTH LATIN SMALL LETTER X]
					output[outputPos++] = 'x';
					break;
				case '\u24B3': // ‚í≥  [PARENTHESIZED LATIN SMALL LETTER X]
					output[outputPos++] = '(';
					output[outputPos++] = 'x';
					output[outputPos++] = ')';
					break;
				case '\u00DD': // √ù  [LATIN CAPITAL LETTER Y WITH ACUTE]
				case '\u0176': // ≈∂  [LATIN CAPITAL LETTER Y WITH CIRCUMFLEX]
				case '\u0178': // ≈∏  [LATIN CAPITAL LETTER Y WITH DIAERESIS]
				case '\u01B3': // ∆≥  [LATIN CAPITAL LETTER Y WITH HOOK]
				case '\u0232': // »≤  [LATIN CAPITAL LETTER Y WITH MACRON]
				case '\u024E': // …é  [LATIN CAPITAL LETTER Y WITH STROKE]
				case '\u028F': //  è  [LATIN LETTER SMALL CAPITAL Y]
				case '\u1E8E': // ·∫é  [LATIN CAPITAL LETTER Y WITH DOT ABOVE]
				case '\u1EF2': // ·ª≤  [LATIN CAPITAL LETTER Y WITH GRAVE]
				case '\u1EF4': // ·ª¥  [LATIN CAPITAL LETTER Y WITH DOT BELOW]
				case '\u1EF6': // ·ª∂  [LATIN CAPITAL LETTER Y WITH HOOK ABOVE]
				case '\u1EF8': // ·ª∏  [LATIN CAPITAL LETTER Y WITH TILDE]
				case '\u1EFE': // ·ªæ  [LATIN CAPITAL LETTER Y WITH LOOP]
				case '\u24CE': // ‚ìé  [CIRCLED LATIN CAPITAL LETTER Y]
				case '\uFF39': // Ôºπ  [FULLWIDTH LATIN CAPITAL LETTER Y]
					output[outputPos++] = 'Y';
					break;
				case '\u00FD': // √Ω  [LATIN SMALL LETTER Y WITH ACUTE]
				case '\u00FF': // √ø  [LATIN SMALL LETTER Y WITH DIAERESIS]
				case '\u0177': // ≈∑  [LATIN SMALL LETTER Y WITH CIRCUMFLEX]
				case '\u01B4': // ∆¥  [LATIN SMALL LETTER Y WITH HOOK]
				case '\u0233': // »≥  [LATIN SMALL LETTER Y WITH MACRON]
				case '\u024F': // …è  [LATIN SMALL LETTER Y WITH STROKE]
				case '\u028E': //  é  [LATIN SMALL LETTER TURNED Y]
				case '\u1E8F': // ·∫è  [LATIN SMALL LETTER Y WITH DOT ABOVE]
				case '\u1E99': // ·∫ô  [LATIN SMALL LETTER Y WITH RING ABOVE]
				case '\u1EF3': // ·ª≥  [LATIN SMALL LETTER Y WITH GRAVE]
				case '\u1EF5': // ·ªµ  [LATIN SMALL LETTER Y WITH DOT BELOW]
				case '\u1EF7': // ·ª∑  [LATIN SMALL LETTER Y WITH HOOK ABOVE]
				case '\u1EF9': // ·ªπ  [LATIN SMALL LETTER Y WITH TILDE]
				case '\u1EFF': // ·ªø  [LATIN SMALL LETTER Y WITH LOOP]
				case '\u24E8': // ‚ì®  [CIRCLED LATIN SMALL LETTER Y]
				case '\uFF59': // ÔΩô  [FULLWIDTH LATIN SMALL LETTER Y]
					output[outputPos++] = 'y';
					break;
				case '\u24B4': // ‚í¥  [PARENTHESIZED LATIN SMALL LETTER Y]
					output[outputPos++] = '(';
					output[outputPos++] = 'y';
					output[outputPos++] = ')';
					break;
				case '\u0179': // ≈π  [LATIN CAPITAL LETTER Z WITH ACUTE]
				case '\u017B': // ≈ª  [LATIN CAPITAL LETTER Z WITH DOT ABOVE]
				case '\u017D': // ≈Ω  [LATIN CAPITAL LETTER Z WITH CARON]
				case '\u01B5': // ∆µ  [LATIN CAPITAL LETTER Z WITH STROKE]
				case '\u021C': // »ú  http://en.wikipedia.org/wiki/Yogh  [LATIN CAPITAL LETTER YOGH]
				case '\u0224': // »§  [LATIN CAPITAL LETTER Z WITH HOOK]
				case '\u1D22': // ·¥¢  [LATIN LETTER SMALL CAPITAL Z]
				case '\u1E90': // ·∫ê  [LATIN CAPITAL LETTER Z WITH CIRCUMFLEX]
				case '\u1E92': // ·∫í  [LATIN CAPITAL LETTER Z WITH DOT BELOW]
				case '\u1E94': // ·∫î  [LATIN CAPITAL LETTER Z WITH LINE BELOW]
				case '\u24CF': // ‚ìè  [CIRCLED LATIN CAPITAL LETTER Z]
				case '\u2C6B': // ‚±´  [LATIN CAPITAL LETTER Z WITH DESCENDER]
				case '\uA762': // Íù¢  [LATIN CAPITAL LETTER VISIGOTHIC Z]
				case '\uFF3A': // Ôº∫  [FULLWIDTH LATIN CAPITAL LETTER Z]
					output[outputPos++] = 'Z';
					break;
				case '\u017A': // ≈∫  [LATIN SMALL LETTER Z WITH ACUTE]
				case '\u017C': // ≈º  [LATIN SMALL LETTER Z WITH DOT ABOVE]
				case '\u017E': // ≈æ  [LATIN SMALL LETTER Z WITH CARON]
				case '\u01B6': // ∆∂  [LATIN SMALL LETTER Z WITH STROKE]
				case '\u021D': // »ù  http://en.wikipedia.org/wiki/Yogh  [LATIN SMALL LETTER YOGH]
				case '\u0225': // »•  [LATIN SMALL LETTER Z WITH HOOK]
				case '\u0240': // …Ä  [LATIN SMALL LETTER Z WITH SWASH TAIL]
				case '\u0290': //  ê  [LATIN SMALL LETTER Z WITH RETROFLEX HOOK]
				case '\u0291': //  ë  [LATIN SMALL LETTER Z WITH CURL]
				case '\u1D76': // ·µ∂  [LATIN SMALL LETTER Z WITH MIDDLE TILDE]
				case '\u1D8E': // ·∂é  [LATIN SMALL LETTER Z WITH PALATAL HOOK]
				case '\u1E91': // ·∫ë  [LATIN SMALL LETTER Z WITH CIRCUMFLEX]
				case '\u1E93': // ·∫ì  [LATIN SMALL LETTER Z WITH DOT BELOW]
				case '\u1E95': // ·∫ï  [LATIN SMALL LETTER Z WITH LINE BELOW]
				case '\u24E9': // ‚ì©  [CIRCLED LATIN SMALL LETTER Z]
				case '\u2C6C': // ‚±¨  [LATIN SMALL LETTER Z WITH DESCENDER]
				case '\uA763': // Íù£  [LATIN SMALL LETTER VISIGOTHIC Z]
				case '\uFF5A': // ÔΩö  [FULLWIDTH LATIN SMALL LETTER Z]
					output[outputPos++] = 'z';
					break;
				case '\u24B5': // ‚íµ  [PARENTHESIZED LATIN SMALL LETTER Z]
					output[outputPos++] = '(';
					output[outputPos++] = 'z';
					output[outputPos++] = ')';
					break;
				case '\u2070': // ‚Å∞  [SUPERSCRIPT ZERO]
				case '\u2080': // ‚ÇÄ  [SUBSCRIPT ZERO]
				case '\u24EA': // ‚ì™  [CIRCLED DIGIT ZERO]
				case '\u24FF': // ‚ìø  [NEGATIVE CIRCLED DIGIT ZERO]
				case '\uFF10': // Ôºê  [FULLWIDTH DIGIT ZERO]
					output[outputPos++] = '0';
					break;
				case '\u00B9': // ¬π  [SUPERSCRIPT ONE]
				case '\u2081': // ‚ÇÅ  [SUBSCRIPT ONE]
				case '\u2460': // ‚ë†  [CIRCLED DIGIT ONE]
				case '\u24F5': // ‚ìµ  [DOUBLE CIRCLED DIGIT ONE]
				case '\u2776': // ‚ù∂  [DINGBAT NEGATIVE CIRCLED DIGIT ONE]
				case '\u2780': // ‚ûÄ  [DINGBAT CIRCLED SANS-SERIF DIGIT ONE]
				case '\u278A': // ‚ûä  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT ONE]
				case '\uFF11': // Ôºë  [FULLWIDTH DIGIT ONE]
					output[outputPos++] = '1';
					break;
				case '\u2488': // ‚íà  [DIGIT ONE FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '.';
					break;
				case '\u2474': // ‚ë¥  [PARENTHESIZED DIGIT ONE]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = ')';
					break;
				case '\u00B2': // ¬≤  [SUPERSCRIPT TWO]
				case '\u2082': // ‚ÇÇ  [SUBSCRIPT TWO]
				case '\u2461': // ‚ë°  [CIRCLED DIGIT TWO]
				case '\u24F6': // ‚ì∂  [DOUBLE CIRCLED DIGIT TWO]
				case '\u2777': // ‚ù∑  [DINGBAT NEGATIVE CIRCLED DIGIT TWO]
				case '\u2781': // ‚ûÅ  [DINGBAT CIRCLED SANS-SERIF DIGIT TWO]
				case '\u278B': // ‚ûã  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT TWO]
				case '\uFF12': // Ôºí  [FULLWIDTH DIGIT TWO]
					output[outputPos++] = '2';
					break;
				case '\u2489': // ‚íâ  [DIGIT TWO FULL STOP]
					output[outputPos++] = '2';
					output[outputPos++] = '.';
					break;
				case '\u2475': // ‚ëµ  [PARENTHESIZED DIGIT TWO]
					output[outputPos++] = '(';
					output[outputPos++] = '2';
					output[outputPos++] = ')';
					break;
				case '\u00B3': // ¬≥  [SUPERSCRIPT THREE]
				case '\u2083': // ‚ÇÉ  [SUBSCRIPT THREE]
				case '\u2462': // ‚ë¢  [CIRCLED DIGIT THREE]
				case '\u24F7': // ‚ì∑  [DOUBLE CIRCLED DIGIT THREE]
				case '\u2778': // ‚ù∏  [DINGBAT NEGATIVE CIRCLED DIGIT THREE]
				case '\u2782': // ‚ûÇ  [DINGBAT CIRCLED SANS-SERIF DIGIT THREE]
				case '\u278C': // ‚ûå  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT THREE]
				case '\uFF13': // Ôºì  [FULLWIDTH DIGIT THREE]
					output[outputPos++] = '3';
					break;
				case '\u248A': // ‚íä  [DIGIT THREE FULL STOP]
					output[outputPos++] = '3';
					output[outputPos++] = '.';
					break;
				case '\u2476': // ‚ë∂  [PARENTHESIZED DIGIT THREE]
					output[outputPos++] = '(';
					output[outputPos++] = '3';
					output[outputPos++] = ')';
					break;
				case '\u2074': // ‚Å¥  [SUPERSCRIPT FOUR]
				case '\u2084': // ‚ÇÑ  [SUBSCRIPT FOUR]
				case '\u2463': // ‚ë£  [CIRCLED DIGIT FOUR]
				case '\u24F8': // ‚ì∏  [DOUBLE CIRCLED DIGIT FOUR]
				case '\u2779': // ‚ùπ  [DINGBAT NEGATIVE CIRCLED DIGIT FOUR]
				case '\u2783': // ‚ûÉ  [DINGBAT CIRCLED SANS-SERIF DIGIT FOUR]
				case '\u278D': // ‚ûç  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FOUR]
				case '\uFF14': // Ôºî  [FULLWIDTH DIGIT FOUR]
					output[outputPos++] = '4';
					break;
				case '\u248B': // ‚íã  [DIGIT FOUR FULL STOP]
					output[outputPos++] = '4';
					output[outputPos++] = '.';
					break;
				case '\u2477': // ‚ë∑  [PARENTHESIZED DIGIT FOUR]
					output[outputPos++] = '(';
					output[outputPos++] = '4';
					output[outputPos++] = ')';
					break;
				case '\u2075': // ‚Åµ  [SUPERSCRIPT FIVE]
				case '\u2085': // ‚ÇÖ  [SUBSCRIPT FIVE]
				case '\u2464': // ‚ë§  [CIRCLED DIGIT FIVE]
				case '\u24F9': // ‚ìπ  [DOUBLE CIRCLED DIGIT FIVE]
				case '\u277A': // ‚ù∫  [DINGBAT NEGATIVE CIRCLED DIGIT FIVE]
				case '\u2784': // ‚ûÑ  [DINGBAT CIRCLED SANS-SERIF DIGIT FIVE]
				case '\u278E': // ‚ûé  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FIVE]
				case '\uFF15': // Ôºï  [FULLWIDTH DIGIT FIVE]
					output[outputPos++] = '5';
					break;
				case '\u248C': // ‚íå  [DIGIT FIVE FULL STOP]
					output[outputPos++] = '5';
					output[outputPos++] = '.';
					break;
				case '\u2478': // ‚ë∏  [PARENTHESIZED DIGIT FIVE]
					output[outputPos++] = '(';
					output[outputPos++] = '5';
					output[outputPos++] = ')';
					break;
				case '\u2076': // ‚Å∂  [SUPERSCRIPT SIX]
				case '\u2086': // ‚ÇÜ  [SUBSCRIPT SIX]
				case '\u2465': // ‚ë•  [CIRCLED DIGIT SIX]
				case '\u24FA': // ‚ì∫  [DOUBLE CIRCLED DIGIT SIX]
				case '\u277B': // ‚ùª  [DINGBAT NEGATIVE CIRCLED DIGIT SIX]
				case '\u2785': // ‚ûÖ  [DINGBAT CIRCLED SANS-SERIF DIGIT SIX]
				case '\u278F': // ‚ûè  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SIX]
				case '\uFF16': // Ôºñ  [FULLWIDTH DIGIT SIX]
					output[outputPos++] = '6';
					break;
				case '\u248D': // ‚íç  [DIGIT SIX FULL STOP]
					output[outputPos++] = '6';
					output[outputPos++] = '.';
					break;
				case '\u2479': // ‚ëπ  [PARENTHESIZED DIGIT SIX]
					output[outputPos++] = '(';
					output[outputPos++] = '6';
					output[outputPos++] = ')';
					break;
				case '\u2077': // ‚Å∑  [SUPERSCRIPT SEVEN]
				case '\u2087': // ‚Çá  [SUBSCRIPT SEVEN]
				case '\u2466': // ‚ë¶  [CIRCLED DIGIT SEVEN]
				case '\u24FB': // ‚ìª  [DOUBLE CIRCLED DIGIT SEVEN]
				case '\u277C': // ‚ùº  [DINGBAT NEGATIVE CIRCLED DIGIT SEVEN]
				case '\u2786': // ‚ûÜ  [DINGBAT CIRCLED SANS-SERIF DIGIT SEVEN]
				case '\u2790': // ‚ûê  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN]
				case '\uFF17': // Ôºó  [FULLWIDTH DIGIT SEVEN]
					output[outputPos++] = '7';
					break;
				case '\u248E': // ‚íé  [DIGIT SEVEN FULL STOP]
					output[outputPos++] = '7';
					output[outputPos++] = '.';
					break;
				case '\u247A': // ‚ë∫  [PARENTHESIZED DIGIT SEVEN]
					output[outputPos++] = '(';
					output[outputPos++] = '7';
					output[outputPos++] = ')';
					break;
				case '\u2078': // ‚Å∏  [SUPERSCRIPT EIGHT]
				case '\u2088': // ‚Çà  [SUBSCRIPT EIGHT]
				case '\u2467': // ‚ëß  [CIRCLED DIGIT EIGHT]
				case '\u24FC': // ‚ìº  [DOUBLE CIRCLED DIGIT EIGHT]
				case '\u277D': // ‚ùΩ  [DINGBAT NEGATIVE CIRCLED DIGIT EIGHT]
				case '\u2787': // ‚ûá  [DINGBAT CIRCLED SANS-SERIF DIGIT EIGHT]
				case '\u2791': // ‚ûë  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT EIGHT]
				case '\uFF18': // Ôºò  [FULLWIDTH DIGIT EIGHT]
					output[outputPos++] = '8';
					break;
				case '\u248F': // ‚íè  [DIGIT EIGHT FULL STOP]
					output[outputPos++] = '8';
					output[outputPos++] = '.';
					break;
				case '\u247B': // ‚ëª  [PARENTHESIZED DIGIT EIGHT]
					output[outputPos++] = '(';
					output[outputPos++] = '8';
					output[outputPos++] = ')';
					break;
				case '\u2079': // ‚Åπ  [SUPERSCRIPT NINE]
				case '\u2089': // ‚Çâ  [SUBSCRIPT NINE]
				case '\u2468': // ‚ë®  [CIRCLED DIGIT NINE]
				case '\u24FD': // ‚ìΩ  [DOUBLE CIRCLED DIGIT NINE]
				case '\u277E': // ‚ùæ  [DINGBAT NEGATIVE CIRCLED DIGIT NINE]
				case '\u2788': // ‚ûà  [DINGBAT CIRCLED SANS-SERIF DIGIT NINE]
				case '\u2792': // ‚ûí  [DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT NINE]
				case '\uFF19': // Ôºô  [FULLWIDTH DIGIT NINE]
					output[outputPos++] = '9';
					break;
				case '\u2490': // ‚íê  [DIGIT NINE FULL STOP]
					output[outputPos++] = '9';
					output[outputPos++] = '.';
					break;
				case '\u247C': // ‚ëº  [PARENTHESIZED DIGIT NINE]
					output[outputPos++] = '(';
					output[outputPos++] = '9';
					output[outputPos++] = ')';
					break;
				case '\u2469': // ‚ë©  [CIRCLED NUMBER TEN]
				case '\u24FE': // ‚ìæ  [DOUBLE CIRCLED NUMBER TEN]
				case '\u277F': // ‚ùø  [DINGBAT NEGATIVE CIRCLED NUMBER TEN]
				case '\u2789': // ‚ûâ  [DINGBAT CIRCLED SANS-SERIF NUMBER TEN]
				case '\u2793': // ‚ûì  [DINGBAT NEGATIVE CIRCLED SANS-SERIF NUMBER TEN]
					output[outputPos++] = '1';
					output[outputPos++] = '0';
					break;
				case '\u2491': // ‚íë  [NUMBER TEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '0';
					output[outputPos++] = '.';
					break;
				case '\u247D': // ‚ëΩ  [PARENTHESIZED NUMBER TEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '0';
					output[outputPos++] = ')';
					break;
				case '\u246A': // ‚ë™  [CIRCLED NUMBER ELEVEN]
				case '\u24EB': // ‚ì´  [NEGATIVE CIRCLED NUMBER ELEVEN]
					output[outputPos++] = '1';
					output[outputPos++] = '1';
					break;
				case '\u2492': // ‚íí  [NUMBER ELEVEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '1';
					output[outputPos++] = '.';
					break;
				case '\u247E': // ‚ëæ  [PARENTHESIZED NUMBER ELEVEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '1';
					output[outputPos++] = ')';
					break;
				case '\u246B': // ‚ë´  [CIRCLED NUMBER TWELVE]
				case '\u24EC': // ‚ì¨  [NEGATIVE CIRCLED NUMBER TWELVE]
					output[outputPos++] = '1';
					output[outputPos++] = '2';
					break;
				case '\u2493': // ‚íì  [NUMBER TWELVE FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '2';
					output[outputPos++] = '.';
					break;
				case '\u247F': // ‚ëø  [PARENTHESIZED NUMBER TWELVE]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '2';
					output[outputPos++] = ')';
					break;
				case '\u246C': // ‚ë¨  [CIRCLED NUMBER THIRTEEN]
				case '\u24ED': // ‚ì≠  [NEGATIVE CIRCLED NUMBER THIRTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '3';
					break;
				case '\u2494': // ‚íî  [NUMBER THIRTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '3';
					output[outputPos++] = '.';
					break;
				case '\u2480': // ‚íÄ  [PARENTHESIZED NUMBER THIRTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '3';
					output[outputPos++] = ')';
					break;
				case '\u246D': // ‚ë≠  [CIRCLED NUMBER FOURTEEN]
				case '\u24EE': // ‚ìÆ  [NEGATIVE CIRCLED NUMBER FOURTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '4';
					break;
				case '\u2495': // ‚íï  [NUMBER FOURTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '4';
					output[outputPos++] = '.';
					break;
				case '\u2481': // ‚íÅ  [PARENTHESIZED NUMBER FOURTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '4';
					output[outputPos++] = ')';
					break;
				case '\u246E': // ‚ëÆ  [CIRCLED NUMBER FIFTEEN]
				case '\u24EF': // ‚ìØ  [NEGATIVE CIRCLED NUMBER FIFTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '5';
					break;
				case '\u2496': // ‚íñ  [NUMBER FIFTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '5';
					output[outputPos++] = '.';
					break;
				case '\u2482': // ‚íÇ  [PARENTHESIZED NUMBER FIFTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '5';
					output[outputPos++] = ')';
					break;
				case '\u246F': // ‚ëØ  [CIRCLED NUMBER SIXTEEN]
				case '\u24F0': // ‚ì∞  [NEGATIVE CIRCLED NUMBER SIXTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '6';
					break;
				case '\u2497': // ‚íó  [NUMBER SIXTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '6';
					output[outputPos++] = '.';
					break;
				case '\u2483': // ‚íÉ  [PARENTHESIZED NUMBER SIXTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '6';
					output[outputPos++] = ')';
					break;
				case '\u2470': // ‚ë∞  [CIRCLED NUMBER SEVENTEEN]
				case '\u24F1': // ‚ì±  [NEGATIVE CIRCLED NUMBER SEVENTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '7';
					break;
				case '\u2498': // ‚íò  [NUMBER SEVENTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '7';
					output[outputPos++] = '.';
					break;
				case '\u2484': // ‚íÑ  [PARENTHESIZED NUMBER SEVENTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '7';
					output[outputPos++] = ')';
					break;
				case '\u2471': // ‚ë±  [CIRCLED NUMBER EIGHTEEN]
				case '\u24F2': // ‚ì≤  [NEGATIVE CIRCLED NUMBER EIGHTEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '8';
					break;
				case '\u2499': // ‚íô  [NUMBER EIGHTEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '8';
					output[outputPos++] = '.';
					break;
				case '\u2485': // ‚íÖ  [PARENTHESIZED NUMBER EIGHTEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '8';
					output[outputPos++] = ')';
					break;
				case '\u2472': // ‚ë≤  [CIRCLED NUMBER NINETEEN]
				case '\u24F3': // ‚ì≥  [NEGATIVE CIRCLED NUMBER NINETEEN]
					output[outputPos++] = '1';
					output[outputPos++] = '9';
					break;
				case '\u249A': // ‚íö  [NUMBER NINETEEN FULL STOP]
					output[outputPos++] = '1';
					output[outputPos++] = '9';
					output[outputPos++] = '.';
					break;
				case '\u2486': // ‚íÜ  [PARENTHESIZED NUMBER NINETEEN]
					output[outputPos++] = '(';
					output[outputPos++] = '1';
					output[outputPos++] = '9';
					output[outputPos++] = ')';
					break;
				case '\u2473': // ‚ë≥  [CIRCLED NUMBER TWENTY]
				case '\u24F4': // ‚ì¥  [NEGATIVE CIRCLED NUMBER TWENTY]
					output[outputPos++] = '2';
					output[outputPos++] = '0';
					break;
				case '\u249B': // ‚íõ  [NUMBER TWENTY FULL STOP]
					output[outputPos++] = '2';
					output[outputPos++] = '0';
					output[outputPos++] = '.';
					break;
				case '\u2487': // ‚íá  [PARENTHESIZED NUMBER TWENTY]
					output[outputPos++] = '(';
					output[outputPos++] = '2';
					output[outputPos++] = '0';
					output[outputPos++] = ')';
					break;
				case '\u00AB': // ¬´  [LEFT-POINTING DOUBLE ANGLE QUOTATION MARK]
				case '\u00BB': // ¬ª  [RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK]
				case '\u201C': // ‚Äú  [LEFT DOUBLE QUOTATION MARK]
				case '\u201D': // ‚Äù  [RIGHT DOUBLE QUOTATION MARK]
				case '\u201E': // ‚Äû  [DOUBLE LOW-9 QUOTATION MARK]
				case '\u2033': // ‚Ä≥  [DOUBLE PRIME]
				case '\u2036': // ‚Ä∂  [REVERSED DOUBLE PRIME]
				case '\u275D': // ‚ùù  [HEAVY DOUBLE TURNED COMMA QUOTATION MARK ORNAMENT]
				case '\u275E': // ‚ùû  [HEAVY DOUBLE COMMA QUOTATION MARK ORNAMENT]
				case '\u276E': // ‚ùÆ  [HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT]
				case '\u276F': // ‚ùØ  [HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT]
				case '\uFF02': // ÔºÇ  [FULLWIDTH QUOTATION MARK]
					output[outputPos++] = '"';
					break;
				case '\u2018': // ‚Äò  [LEFT SINGLE QUOTATION MARK]
				case '\u2019': // ‚Äô  [RIGHT SINGLE QUOTATION MARK]
				case '\u201A': // ‚Äö  [SINGLE LOW-9 QUOTATION MARK]
				case '\u201B': // ‚Äõ  [SINGLE HIGH-REVERSED-9 QUOTATION MARK]
				case '\u2032': // ‚Ä≤  [PRIME]
				case '\u2035': // ‚Äµ  [REVERSED PRIME]
				case '\u2039': // ‚Äπ  [SINGLE LEFT-POINTING ANGLE QUOTATION MARK]
				case '\u203A': // ‚Ä∫  [SINGLE RIGHT-POINTING ANGLE QUOTATION MARK]
				case '\u275B': // ‚ùõ  [HEAVY SINGLE TURNED COMMA QUOTATION MARK ORNAMENT]
				case '\u275C': // ‚ùú  [HEAVY SINGLE COMMA QUOTATION MARK ORNAMENT]
				case '\uFF07': // Ôºá  [FULLWIDTH APOSTROPHE]
				case '\u02BC': // aprostrofo genitivo sassone e carattere ebraico (ticket 2984)
					output[outputPos++] = '\'';
					break;
				case '\u2010': // ‚Äê  [HYPHEN]
				case '\u2011': // ‚Äë  [NON-BREAKING HYPHEN]
				case '\u2012': // ‚Äí  [FIGURE DASH]
				case '\u2013': // ‚Äì  [EN DASH]
				case '\u2014': // ‚Äî  [EM DASH]
				case '\u207B': // ‚Åª  [SUPERSCRIPT MINUS]
				case '\u208B': // ‚Çã  [SUBSCRIPT MINUS]
				case '\uFF0D': // Ôºç  [FULLWIDTH HYPHEN-MINUS]
					output[outputPos++] = '-';
					break;
				case '\u2045': // ‚ÅÖ  [LEFT SQUARE BRACKET WITH QUILL]
				case '\u2772': // ‚ù≤  [LIGHT LEFT TORTOISE SHELL BRACKET ORNAMENT]
				case '\uFF3B': // Ôºª  [FULLWIDTH LEFT SQUARE BRACKET]
					output[outputPos++] = '[';
					break;
				case '\u2046': // ‚ÅÜ  [RIGHT SQUARE BRACKET WITH QUILL]
				case '\u2773': // ‚ù≥  [LIGHT RIGHT TORTOISE SHELL BRACKET ORNAMENT]
				case '\uFF3D': // ÔºΩ  [FULLWIDTH RIGHT SQUARE BRACKET]
					output[outputPos++] = ']';
					break;
				case '\u207D': // ‚ÅΩ  [SUPERSCRIPT LEFT PARENTHESIS]
				case '\u208D': // ‚Çç  [SUBSCRIPT LEFT PARENTHESIS]
				case '\u2768': // ‚ù®  [MEDIUM LEFT PARENTHESIS ORNAMENT]
				case '\u276A': // ‚ù™  [MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT]
				case '\uFF08': // Ôºà  [FULLWIDTH LEFT PARENTHESIS]
					output[outputPos++] = '(';
					break;
				case '\u2E28': // ‚∏®  [LEFT DOUBLE PARENTHESIS]
					output[outputPos++] = '(';
					output[outputPos++] = '(';
					break;
				case '\u207E': // ‚Åæ  [SUPERSCRIPT RIGHT PARENTHESIS]
				case '\u208E': // ‚Çé  [SUBSCRIPT RIGHT PARENTHESIS]
				case '\u2769': // ‚ù©  [MEDIUM RIGHT PARENTHESIS ORNAMENT]
				case '\u276B': // ‚ù´  [MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT]
				case '\uFF09': // Ôºâ  [FULLWIDTH RIGHT PARENTHESIS]
					output[outputPos++] = ')';
					break;
				case '\u2E29': // ‚∏©  [RIGHT DOUBLE PARENTHESIS]
					output[outputPos++] = ')';
					output[outputPos++] = ')';
					break;
				case '\u276C': // ‚ù¨  [MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT]
				case '\u2770': // ‚ù∞  [HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT]
				case '\uFF1C': // Ôºú  [FULLWIDTH LESS-THAN SIGN]
					output[outputPos++] = '<';
					break;
				case '\u276D': // ‚ù≠  [MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT]
				case '\u2771': // ‚ù±  [HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT]
				case '\uFF1E': // Ôºû  [FULLWIDTH GREATER-THAN SIGN]
					output[outputPos++] = '>';
					break;
				case '\u2774': // ‚ù¥  [MEDIUM LEFT CURLY BRACKET ORNAMENT]
				case '\uFF5B': // ÔΩõ  [FULLWIDTH LEFT CURLY BRACKET]
					output[outputPos++] = '{';
					break;
				case '\u2775': // ‚ùµ  [MEDIUM RIGHT CURLY BRACKET ORNAMENT]
				case '\uFF5D': // ÔΩù  [FULLWIDTH RIGHT CURLY BRACKET]
					output[outputPos++] = '}';
					break;
				case '\u207A': // ‚Å∫  [SUPERSCRIPT PLUS SIGN]
				case '\u208A': // ‚Çä  [SUBSCRIPT PLUS SIGN]
				case '\uFF0B': // Ôºã  [FULLWIDTH PLUS SIGN]
					output[outputPos++] = '+';
					break;
				case '\u207C': // ‚Åº  [SUPERSCRIPT EQUALS SIGN]
				case '\u208C': // ‚Çå  [SUBSCRIPT EQUALS SIGN]
				case '\uFF1D': // Ôºù  [FULLWIDTH EQUALS SIGN]
					output[outputPos++] = '=';
					break;
				case '\uFF01': // ÔºÅ  [FULLWIDTH EXCLAMATION MARK]
					output[outputPos++] = '!';
					break;
				case '\u203C': // ‚Äº  [DOUBLE EXCLAMATION MARK]
					output[outputPos++] = '!';
					output[outputPos++] = '!';
					break;
				case '\u2049': // ‚Åâ  [EXCLAMATION QUESTION MARK]
					output[outputPos++] = '!';
					output[outputPos++] = '?';
					break;
				case '\uFF03': // ÔºÉ  [FULLWIDTH NUMBER SIGN]
					output[outputPos++] = '#';
					break;
				case '\uFF04': // ÔºÑ  [FULLWIDTH DOLLAR SIGN]
					output[outputPos++] = '$';
					break;
				case '\u2052': // ‚Åí  [COMMERCIAL MINUS SIGN]
				case '\uFF05': // ÔºÖ  [FULLWIDTH PERCENT SIGN]
					output[outputPos++] = '%';
					break;
				case '\uFF06': // ÔºÜ  [FULLWIDTH AMPERSAND]
					output[outputPos++] = '&';
					break;
				case '\u204E': // ‚Åé  [LOW ASTERISK]
				case '\uFF0A': // Ôºä  [FULLWIDTH ASTERISK]
					output[outputPos++] = '*';
					break;
				case '\uFF0C': // Ôºå  [FULLWIDTH COMMA]
					output[outputPos++] = ',';
					break;
				case '\uFF0E': // Ôºé  [FULLWIDTH FULL STOP]
					output[outputPos++] = '.';
					break;
				case '\u2044': // ‚ÅÑ  [FRACTION SLASH]
				case '\uFF0F': // Ôºè  [FULLWIDTH SOLIDUS]
					output[outputPos++] = '/';
					break;
				case '\uFF1A': // Ôºö  [FULLWIDTH COLON]
					output[outputPos++] = ':';
					break;
				case '\u204F': // ‚Åè  [REVERSED SEMICOLON]
				case '\uFF1B': // Ôºõ  [FULLWIDTH SEMICOLON]
					output[outputPos++] = ';';
					break;
				case '\uFF1F': // Ôºü  [FULLWIDTH QUESTION MARK]
					output[outputPos++] = '?';
					break;
				case '\u2047': // ‚Åá  [DOUBLE QUESTION MARK]
					output[outputPos++] = '?';
					output[outputPos++] = '?';
					break;
				case '\u2048': // ‚Åà  [QUESTION EXCLAMATION MARK]
					output[outputPos++] = '?';
					output[outputPos++] = '!';
					break;
				case '\uFF20': // Ôº†  [FULLWIDTH COMMERCIAL AT]
					output[outputPos++] = '@';
					break;
				case '\uFF3C': // Ôºº  [FULLWIDTH REVERSE SOLIDUS]
					output[outputPos++] = '\\';
					break;
				case '\u2038': // ‚Ä∏  [CARET]
				case '\uFF3E': // Ôºæ  [FULLWIDTH CIRCUMFLEX ACCENT]
					output[outputPos++] = '^';
					break;
				case '\uFF3F': // Ôºø  [FULLWIDTH LOW LINE]
					output[outputPos++] = '_';
					break;
				case '\u2053': // ‚Åì  [SWUNG DASH]
				case '\uFF5E': // ÔΩû  [FULLWIDTH TILDE]
					output[outputPos++] = '~';
					break;
				default:
					output[outputPos++] = c;
					break;
				}
			}
		}
		return output;
	}
	public static int getNextSize(int targetSize) {
		/* This over-allocates proportional to the list size, making room
		 * for additional growth.  The over-allocation is mild, but is
		 * enough to give linear-time amortized behavior over a long
		 * sequence of appends() in the presence of a poorly-performing
		 * system realloc().
		 * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
		 */
		return (targetSize >> 3) + (targetSize < 9 ? 3 : 6) + targetSize;
	}
	public static void main(String[] args) {
		String test = "xxxxxx1baaaaaab1xxxxxxx";
		test = test.substring(7,15);
		System.out.println(test);
	}
}

